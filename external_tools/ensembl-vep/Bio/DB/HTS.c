/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.34 from the
 * contents of HTS.xs. Do not edit this file, edit HTS.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "lib/Bio/DB/HTS.xs"
/*
Copyright [2015-2018] EMBL-European Bioinformatics Institute

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#ifdef PERL_CAPI
#define WIN32IO_IS_STDIO
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#ifdef FCGI
 #include <fcgi_stdio.h>
#else
 #ifdef USE_SFIO
  #include <config.h>
 #else
  #include <stdio.h>
 #endif
 #include <perlio.h>
#endif

#define TRACEME(x) do {						\
    if (SvTRUE(perl_get_sv("Bio::DB::HTS::ENABLE_DEBUG", TRUE)))	\
      { PerlIO_stdoutf (x); PerlIO_stdoutf ("\n"); }		\
  } while (0)

#ifndef Newx
#  define Newx(v,n,t) New(0,v,n,t)
#endif

#ifndef Newxz
#  define Newxz(v,n,t) Newz(0,v,n,t)
#endif

#include <unistd.h>
#include <math.h>
#include <string.h>
#include <zlib.h>

#include "htslib/kseq.h"
#include "htslib/hts.h"
#include "htslib/hfile.h"
#include "htslib/sam.h"
#include "htslib/faidx.h"
#include "htslib/tbx.h"
#include "htslib/bgzf.h"
#include "htslib/vcf.h"
#include "htslib/vcfutils.h"
#include "htslib/vcf_sweep.h"
#include "htslib/synced_bcf_reader.h"

#include "htslib/khash.h"
KHASH_MAP_INIT_STR(vdict, bcf_idinfo_t)
typedef khash_t(vdict) vdict_t;

/* stolen from bam_aux.c */
#define BAM_MAX_REGION 1<<29

typedef htsFile*        Bio__DB__HTSfile;
typedef htsFile*        Bio__DB__HTS__VCFfile;
typedef bam_hdr_t*      Bio__DB__HTS__Header;
typedef bam1_t*         Bio__DB__HTS__Alignment;
typedef hts_idx_t*      Bio__DB__HTS__Index;
typedef faidx_t*        Bio__DB__HTS__Fai;
typedef bam_pileup1_t*  Bio__DB__HTS__Pileup;
typedef tbx_t*          Bio__DB__HTS__Tabix;
typedef hts_itr_t*      Bio__DB__HTS__Tabix__Iterator;
typedef vcfFile*        Bio__DB__HTS__VCFfile;
typedef hts_itr_t*      Bio__DB__HTS__VCF__Iterator;
typedef bcf_hdr_t*      Bio__DB__HTS__VCF__Header;
typedef bcf_hdr_t*      Bio__DB__HTS__VCF__HeaderPtr;
typedef bcf1_t*         Bio__DB__HTS__VCF__Row;
typedef bcf1_t*         Bio__DB__HTS__VCF__RowPtr;
KSEQ_INIT(gzFile, gzread)
typedef gzFile          Bio__DB__HTS__Kseq;
typedef kseq_t*         Bio__DB__HTS__Kseq__Iterator;
typedef kstream_t*      Bio__DB__HTS__Kseq__Kstream;
typedef kstring_t*      Bio__DB__HTS__Kseq__Kstring;
typedef bcf_sweep_t*    Bio__DB__HTS__VCF__Sweep;

typedef struct {
  SV* callback;
  SV* data;
} fetch_callback_data;
typedef fetch_callback_data *fetch_callback_dataptr;
typedef struct {
  int    start;
  int    end;
  double width;
  int    reads;
  int*   bin;
} coverage_graph;
typedef coverage_graph *coverage_graph_ptr;

static int MaxPileupCnt=8000;

void XS_pack_charPtrPtr( SV * arg, char ** array, int count) {
  int i;
  AV * avref;
  avref = (AV*)sv_2mortal((SV*)newAV());
  for (i=0; i<count; i++) {
    av_push(avref, newSVpv(array[i], strlen(array[i])));
  }
  SvSetSV( arg, newRV((SV*)avref));
}

static int invoke_sv_to_int_fun(SV *func, SV *arg)
{
  dSP;
  int count, ret;

  ENTER;
  SAVETMPS;

  PUSHMARK(SP);
  XPUSHs(arg);
  PUTBACK;

  count = call_sv(func, G_SCALAR);
  SPAGAIN;

  if (count != 1) return -1;

  ret = POPi;
  PUTBACK;
  FREETMPS;
  LEAVE;

  return ret;
}

int hts_fetch_fun (void *data, bam1_t *b)
{
  dSP;
  int count;

  fetch_callback_dataptr fcp;
  SV* callback;
  SV* callbackdata;
  SV* alignment_obj;
  bam1_t *b2;

  fcp          = (fetch_callback_dataptr) data;
  callback     = fcp->callback;
  callbackdata = fcp->data;

  /* The underlying bam1_t will be bam_destroy1()ed by alignment_obj's
   * destructor, so we need to duplicate it here. We could create the Perl SV
   * alongside the C bam1_t (cf bami_coverage), but note that a new b & b_sv
   * would be needed for each iteration, as some callback functions will
   * expect distinct references to distinct alignment objects each time.
   */
  b2 = bam_dup1(b);

  alignment_obj = sv_setref_pv(newSV(sizeof(bam1_t)),"Bio::DB::HTS::Alignment",(void*) b2);

  /* set up subroutine stack for the call */
  ENTER;
  SAVETMPS;

  PUSHMARK(SP);
  XPUSHs(sv_2mortal(alignment_obj));
  XPUSHs(callbackdata);
  PUTBACK;

  /* execute the call */
  count = call_sv(callback,G_SCALAR|G_DISCARD);

  FREETMPS;
  LEAVE;

  return 1;
}

int invoke_pileup_callback_fun(uint32_t tid,
			       uint32_t pos,
			       int n,
			       const bam_pileup1_t *pl,
			       void *data) {
  dSP;
  int count,i;
  fetch_callback_dataptr fcp;
  SV*  callback;
  SV*  callbackdata;
  SV* p;
  AV*  pileup;

  fcp          = (fetch_callback_dataptr) data;
  callback     = fcp->callback;
  callbackdata = fcp->data;

  /* turn the bam_pileup1_t into the appropriate object */
  /* this causes a compiler warning -- ignore it */
  pileup = newAV();
  av_extend(pileup,n);
  for (i=0;i<n;i++) {
    p = newSV(sizeof(bam_pileup1_t));
    sv_setref_pv(p,"Bio::DB::HTS::Pileup",(void*) &pl[i]);
    av_push(pileup,p);
  }

  /* set up subroutine stack for the call */
  ENTER;
  SAVETMPS;

  PUSHMARK(SP);
  XPUSHs(sv_2mortal(newSViv(tid)));
  XPUSHs(sv_2mortal(newSViv(pos)));
  XPUSHs(sv_2mortal(newRV_noinc((SV*)pileup)));
  XPUSHs(callbackdata);
  PUTBACK;

  /* execute the call */
  count = call_sv(callback,G_SCALAR|G_DISCARD);

  FREETMPS;
  LEAVE;

  return 0;
}

/*
   Declarations to allow add_pileup_line to work
   Ported from samtoosl v1 setup.
*/

/* start pileup support copy from bam.h in samtools */
/* but pileup functions are offered as bam_plp_auto_f in htslib */

typedef int (*bam_pileup_f)(uint32_t tid, uint32_t pos, int n, const bam_pileup1_t *pl, void *data);

typedef struct
{
  bam_plp_t iter;
  bam_pileup_f func;
  void *data;
} hts_plbuf_t;


hts_plbuf_t *hts_plbuf_init(bam_pileup_f func, void *data)
{
    hts_plbuf_t *buf;
    buf = calloc(1, sizeof(hts_plbuf_t));
    buf->iter = bam_plp_init(0, 0);
    buf->func = func;
    buf->data = data;
    return buf;
}

void hts_plbuf_destroy(hts_plbuf_t *buf)
{
    bam_plp_destroy(buf->iter);
    free(buf);
}

int hts_plbuf_push(const bam1_t *b, hts_plbuf_t *buf)
{
    int ret, n_plp, tid, pos;
    const bam_pileup1_t *plp;
    ret = bam_plp_push(buf->iter, b);
    if (ret < 0) return ret;
    while ((plp = bam_plp_next(buf->iter, &tid, &pos, &n_plp)) != 0)
        buf->func(tid, pos, n_plp, plp, buf->data);
    return 0;
}


/* end pileup support copy from bam.h in samtools */

/**
   pileup support functions
*/
int add_pileup_line (void *data, bam1_t *b)
{
  hts_plbuf_t *pileup = (hts_plbuf_t*) data;
  hts_plbuf_push(b,pileup);
  return 0;
}



int coverage_from_pileup_fun (uint32_t tid,
			      uint32_t pos,
			      int n,
			      const bam_pileup1_t *pl,
			      void *data) {
  coverage_graph_ptr  cgp;
  int                 bin;
  int                 i;
  int                 valid;

  cgp = (coverage_graph_ptr) data;
  cgp->reads += n;

  valid = 0;
  for (i=0;i<n;i++) {
    if (!pl[i].is_del && !pl[i].is_refskip)
        valid++;
  }

  if (pos >= cgp->start && pos <= cgp->end) {
    bin = (pos-cgp->start)/cgp->width;
    cgp->bin[bin] += valid;
  }

  return 0;
}


/**
   From bam_aux.c in samtools. Needed to allow pileup function to work.
*/
int bam_parse_region(bam_hdr_t *header, const char *str, int *ref_id, int *beg, int *end)
{
    const char *name_lim = hts_parse_reg(str, beg, end);
    if (name_lim) {
        char *name = malloc(name_lim - str + 1);
        memcpy(name, str, name_lim - str);
        name[name_lim - str] = '\0';
        *ref_id = bam_name2id(header, name);
        free(name);
    }
    else {
        // not parsable as a region, but possibly a sequence named "foo:a"
        *ref_id = bam_name2id(header, str);
        *beg = 0; *end = INT_MAX;
    }
    if (*ref_id == -1) return -1;
    return *beg <= *end? 0 : -1;
}

/**
   From bam.c in samtools - these are wrappers that can be used OK here.
*/
char *bam_format1(const bam_hdr_t *header, const bam1_t *b)
{
    kstring_t str;
    str.l = str.m = 0; str.s = NULL;
    sam_format1(header, b, &str);
    return str.s;
}


void bam_view1(const bam_hdr_t *header, const bam1_t *b)
{
        char *s = bam_format1(header, b);
        puts(s);
        free(s);
}


/**
   Get the file extension for a filename
*/
int get_index_fmt_from_extension(const char * filename)
{
  char * ext = strrchr( filename, '.' ) ;
  if( strcmp(ext, ".cram")==0 )
  {
    return HTS_FMT_CRAI ;
  }
  if( strcmp(ext, ".bam")==0 )
  {
    return HTS_FMT_BAI ; //could also be HTS_FMT_CSI
  }
  return -1 ;
}

/**
   fetch function
*/
int hts_fetch(htsFile *fp, const hts_idx_t *idx, int tid, int beg, int end, void *data, bam_plp_auto_f func)
{
    int ret;
    hts_itr_t *iter ;
    bam1_t *b ;

    iter = sam_itr_queryi(idx, tid, beg, end);
    b = bam_init1();

    while((ret = sam_itr_next(fp, iter, b)) >= 0)
    {
        func(data,b);
    }
    hts_itr_destroy(iter);
    bam_destroy1(b);
    return (ret == -1)? 0 : ret;
}


#line 413 "lib/Bio/DB/HTS.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%" UVxf ")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 557 "lib/Bio/DB/HTS.c"

XS_EUPXS(XS_Bio__DB__HTS_htslib_version); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS_htslib_version)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "packname=\"Bio::DB::HTS\"");
    {
	char *	packname;
	SV *	RETVAL;

	if (items < 1)
	    packname = "Bio::DB::HTS";
	else {
	    packname = (char *)SvPV_nolen(ST(0))
;
	}
#line 410 "lib/Bio/DB/HTS.xs"
    RETVAL = newSVpv(hts_version(), 0);
#line 577 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Fai_load); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Fai_load)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "packname=\"Bio::DB::HTS::Fai\", filename");
    {
	char *	packname;
	char *	filename = (char *)SvPV_nolen(ST(1))
;
	Bio__DB__HTS__Fai	RETVAL;

	if (items < 1)
	    packname = "Bio::DB::HTS::Fai";
	else {
	    packname = (char *)SvPV_nolen(ST(0))
;
	}
#line 422 "lib/Bio/DB/HTS.xs"
    RETVAL = fai_load(filename);
#line 605 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Fai", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Fai_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Fai_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "fai");
    {
	Bio__DB__HTS__Fai	fai;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    fai = INT2PTR(Bio__DB__HTS__Fai,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"Bio::DB::HTS::Fai::DESTROY",
			"fai")
;
#line 431 "lib/Bio/DB/HTS.xs"
    fai_destroy(fai);
#line 637 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Fai_fetch); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Fai_fetch)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "fai, reg");
    {
	Bio__DB__HTS__Fai	fai;
	const char *	reg = (const char *)SvPV_nolen(ST(1))
;
#line 439 "lib/Bio/DB/HTS.xs"
    char     *seq;
    int       len;
#line 656 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Fai")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    fai = INT2PTR(Bio__DB__HTS__Fai,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Fai::fetch",
			"fai", "Bio::DB::HTS::Fai")
;
#line 442 "lib/Bio/DB/HTS.xs"
    seq = fai_fetch(fai,reg,&len);
    if (seq == NULL)
       XSRETURN_EMPTY;
    RETVAL = newSVpv(seq,len);
    free((void*)seq);
#line 674 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTSfile_max_pileup_cnt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_max_pileup_cnt)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "packname, ...");
    {
	int	RETVAL;
	dXSTARG;
#line 456 "lib/Bio/DB/HTS.xs"
	if (items > 1)
	   MaxPileupCnt = SvIV(ST(1));
	RETVAL = MaxPileupCnt;
#line 695 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTSfile_is_remote); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_is_remote)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "packname, filename");
    {
	char *	packname = (char *)SvPV_nolen(ST(0))
;
	char *	filename = (char *)SvPV_nolen(ST(1))
;
	int	RETVAL;
	dXSTARG;
#line 469 "lib/Bio/DB/HTS.xs"
        RETVAL = hisremote(filename) ;
#line 717 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTSfile_open); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_open)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "packname, filename, mode=\"r\"");
    {
	char *	packname = (char *)SvPV_nolen(ST(0))
;
	char *	filename = (char *)SvPV_nolen(ST(1))
;
	char *	mode;
	Bio__DB__HTSfile	RETVAL;

	if (items < 3)
	    mode = "r";
	else {
	    mode = (char *)SvPV_nolen(ST(2))
;
	}
#line 483 "lib/Bio/DB/HTS.xs"
        RETVAL = hts_open(filename,mode);
#line 746 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTSfile", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTSfile_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "htsfile");
    {
	Bio__DB__HTSfile	htsfile;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    htsfile = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"Bio::DB::HTSfile::DESTROY",
			"htsfile")
;
#line 493 "lib/Bio/DB/HTS.xs"
   hts_close(htsfile);
#line 778 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTSfile_index_build); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_index_build)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "packname, filename");
    {
	char *	packname = (char *)SvPV_nolen(ST(0))
;
	const char *	filename = (const char *)SvPV_nolen(ST(1))
;
	int	RETVAL;
	dXSTARG;
#line 501 "lib/Bio/DB/HTS.xs"
     RETVAL = sam_index_build(filename,0); //generate BAI for BAM files
#line 799 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTSfile_index_load); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_index_load)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "packname, htsfile");
    {
	char *	packname = (char *)SvPV_nolen(ST(0))
;
	Bio__DB__HTSfile	htsfile;
#line 511 "lib/Bio/DB/HTS.xs"
      SV *htsfile_sv = SvRV(ST(1));
      HV *assocfile = get_hv("Bio::DB::HTS::_associated_file", GV_ADD);
#line 819 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__Index	RETVAL;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    htsfile = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTSfile::index_load",
			"htsfile", "Bio::DB::HTSfile")
;
#line 514 "lib/Bio/DB/HTS.xs"
      RETVAL = sam_index_load(htsfile, htsfile->fn) ;

      /* For CRAM, it is important that this hts_idx_t is destroyed *before*
       * the associated htsFile. We hold on to a reference to the htsFile
       * (which we'll release in our destructor) to ensure it outlives us.
       */
      SvREFCNT_inc(htsfile_sv);
      hv_store(assocfile, (char *) &RETVAL, sizeof RETVAL, htsfile_sv, 0);
#line 840 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Index", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTSfile_header_read); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_header_read)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "htsfile");
    {
	Bio__DB__HTSfile	htsfile;
#line 530 "lib/Bio/DB/HTS.xs"
      bam_hdr_t *bh;
      int64_t result ;
      const htsFormat *format ;
#line 864 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__Header	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    htsfile = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTSfile::header_read",
			"htsfile", "Bio::DB::HTSfile")
;
#line 534 "lib/Bio/DB/HTS.xs"
      format = hts_get_format( htsfile ) ;
      if( format->format == bam  ) //enum value from htsExactFormat from hts.h
        result = bgzf_seek(htsfile->fp.bgzf,0,0) ;
      /*
       * https://github.com/Ensembl/Bio-DB-HTS/issues/54
       * must seek at beginning of file for sam as well
       */
      else if ( format->format == sam ) {
	/*
	 * Using hseek with htslib < 1.5 triggers segfault
	 * and couldn't find a valid alternative.
	 *
	 * WARNING: we're tied to buggy behaviour for htslib <= 1.3.1
	 */
	if ( strcmp(hts_version(), "1.5") >= 0 )
	  result = hseek(htsfile->fp.hfile, 0, SEEK_SET);
      }

      bh = sam_hdr_read(htsfile);
      RETVAL = bh ;
#line 897 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Header", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTSfile_header_write); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_header_write)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "htsfile, header, ...");
    {
	Bio__DB__HTSfile	htsfile;
	Bio__DB__HTS__Header	header;
#line 563 "lib/Bio/DB/HTS.xs"
      char *reference = "";
      const htsFormat *format ;
#line 921 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    htsfile = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTSfile::header_write",
			"htsfile", "Bio::DB::HTSfile")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTSfile::header_write",
			"header", "Bio::DB::HTS::Header")
;
#line 567 "lib/Bio/DB/HTS.xs"
      format = hts_get_format( htsfile ) ;
      if( format->format == cram )
      {
        if(items > 2)
        {
          reference = (char *)SvPV_nolen(ST(2));
          hts_set_fai_filename(htsfile, reference);
        }
        else
        {
          croak("Error: need reference sequence file for writing CRAM file '%s'", htsfile->fn);
        }
      }
      RETVAL= sam_hdr_write(htsfile,header);
      if (RETVAL != 0)
        croak("Error %d while creating file '%s'", RETVAL, htsfile->fn);
#line 961 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTSfile_read1); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_read1)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "htsfile, header");
    {
	Bio__DB__HTSfile	htsfile;
	Bio__DB__HTS__Header	header;
#line 592 "lib/Bio/DB/HTS.xs"
    bam1_t *alignment;
#line 979 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__Alignment	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    htsfile = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTSfile::read1",
			"htsfile", "Bio::DB::HTSfile")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTSfile::read1",
			"header", "Bio::DB::HTS::Header")
;
#line 594 "lib/Bio/DB/HTS.xs"
       alignment = bam_init1();
       if (sam_read1(htsfile,header,alignment) >= 0) {
         RETVAL = alignment ;
       }
       else {
         bam_destroy1(alignment);
         XSRETURN_EMPTY;
       }
#line 1010 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Alignment", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTSfile_write1); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTSfile_write1)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "htsfile, header, align");
    {
	Bio__DB__HTSfile	htsfile;
	Bio__DB__HTS__Header	header;
	Bio__DB__HTS__Alignment	align;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    htsfile = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTSfile::write1",
			"htsfile", "Bio::DB::HTSfile")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTSfile::write1",
			"header", "Bio::DB::HTS::Header")
;

	if (SvROK(ST(2)) && sv_derived_from(ST(2), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    align = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTSfile::write1",
			"align", "Bio::DB::HTS::Alignment")
;
#line 612 "lib/Bio/DB/HTS.xs"
      RETVAL = sam_write1(htsfile,header,align);
#line 1066 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_new)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "package=\"Bio::DB::HTS::Alignment\"");
    {
	char *	package;
	Bio__DB__HTS__Alignment	RETVAL;

	if (items < 1)
	    package = "Bio::DB::HTS::Alignment";
	else {
	    package = (char *)SvPV_nolen(ST(0))
;
	}
#line 623 "lib/Bio/DB/HTS.xs"
      RETVAL = bam_init1();
#line 1091 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Alignment", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"Bio::DB::HTS::Alignment::DESTROY",
			"b")
;
#line 632 "lib/Bio/DB/HTS.xs"
    bam_destroy1(b);
#line 1123 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_tid); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_tid)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::tid",
			"b", "Bio::DB::HTS::Alignment")
;
#line 639 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.tid = SvIV(ST(1));
    RETVAL=b->core.tid;
#line 1153 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_pos); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_pos)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::pos",
			"b", "Bio::DB::HTS::Alignment")
;
#line 650 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.pos = SvIV(ST(1));
    RETVAL=b->core.pos;
#line 1184 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_calend); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_calend)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::calend",
			"b", "Bio::DB::HTS::Alignment")
;
#line 661 "lib/Bio/DB/HTS.xs"
   RETVAL=bam_endpos(b);
#line 1213 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_cigar2qlen); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_cigar2qlen)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::cigar2qlen",
			"b", "Bio::DB::HTS::Alignment")
;
#line 670 "lib/Bio/DB/HTS.xs"
   RETVAL=bam_cigar2qlen(b->core.n_cigar,bam_get_cigar(b));
#line 1242 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_qual); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_qual)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::qual",
			"b", "Bio::DB::HTS::Alignment")
;
#line 679 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.qual = SvIV(ST(1));
    RETVAL=b->core.qual;
#line 1273 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_flag); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_flag)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::flag",
			"b", "Bio::DB::HTS::Alignment")
;
#line 690 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.flag = SvIV(ST(1));
    RETVAL=b->core.flag;
#line 1304 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_n_cigar); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_n_cigar)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::n_cigar",
			"b", "Bio::DB::HTS::Alignment")
;
#line 701 "lib/Bio/DB/HTS.xs"
  if (items > 1)
    b->core.n_cigar = SvIV(ST(1));
    RETVAL=b->core.n_cigar;
#line 1335 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_l_qseq); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_l_qseq)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::l_qseq",
			"b", "Bio::DB::HTS::Alignment")
;
#line 712 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.l_qseq = SvIV(ST(1));
    RETVAL=b->core.l_qseq;
#line 1366 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_qseq); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_qseq)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
#line 723 "lib/Bio/DB/HTS.xs"
    char* seq;
    int   i;
#line 1384 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::qseq",
			"b", "Bio::DB::HTS::Alignment")
;
#line 726 "lib/Bio/DB/HTS.xs"
    Newxz(seq,b->core.l_qseq+1,char);
    for (i=0;i<b->core.l_qseq;i++) {
      seq[i]=seq_nt16_str[bam_seqi(bam_get_seq(b),i)];
    }
    RETVAL = newSVpv(seq,b->core.l_qseq);
    Safefree(seq);
#line 1403 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment__qscore); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment__qscore)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::_qscore",
			"b", "Bio::DB::HTS::Alignment")
;
#line 740 "lib/Bio/DB/HTS.xs"
    RETVAL = newSVpv((char *) bam_get_qual(b),b->core.l_qseq);
#line 1432 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_mtid); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_mtid)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::mtid",
			"b", "Bio::DB::HTS::Alignment")
;
#line 749 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.mtid = SvIV(ST(1));
    RETVAL=b->core.mtid;
#line 1464 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_mpos); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_mpos)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::mpos",
			"b", "Bio::DB::HTS::Alignment")
;
#line 760 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.mpos = SvIV(ST(1));
    RETVAL=b->core.mpos;
#line 1495 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_isize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_isize)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::isize",
			"b", "Bio::DB::HTS::Alignment")
;
#line 771 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->core.isize = SvIV(ST(1));
    RETVAL=b->core.isize;
#line 1526 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_l_aux); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_l_aux)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::l_aux",
			"b", "Bio::DB::HTS::Alignment")
;
#line 782 "lib/Bio/DB/HTS.xs"
    RETVAL=SvIV(newSViv(bam_get_l_aux(b)));
#line 1555 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_aux); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_aux)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
#line 790 "lib/Bio/DB/HTS.xs"
   uint8_t *s;
   uint8_t type, key[2];
   char    str[8192];
#line 1574 "lib/Bio/DB/HTS.c"
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::aux",
			"b", "Bio::DB::HTS::Alignment")
;
#line 794 "lib/Bio/DB/HTS.xs"
   s = bam_get_aux(b);
   str[0] = '\0';

   int left  = sizeof(str) - strlen(str);
   while (left > 0 && (s < b->data + b->l_data)) {
        char* d   = str+strlen(str);

	key[0] = s[0];
	key[1] = s[1];
 	left -= snprintf(d, left, "%c%c:", key[0], key[1]);

	d    += 3;
	s    += 2;
	type = *s++;

	if (left <= 0) continue;

	if (type == 'A')      { left -= snprintf(d, left, "A:%c", *s);           s++; }
	else if (type == 'C') { left -= snprintf(d, left, "i:%u", *s);           s++; }
	else if (type == 'c') { left -= snprintf(d, left, "i:%d", *s);           s++; }
	else if (type == 'S') { left -= snprintf(d, left, "i:%u", *(uint16_t*)s);s += 2; }
	else if (type == 's') { left -= snprintf(d, left, "i:%d", *(int16_t*)s); s += 2; }
	else if (type == 'I') { left -= snprintf(d, left, "i:%u", *(uint32_t*)s);s += 4; }
	else if (type == 'i') { left -= snprintf(d, left, "i:%d", *(int32_t*)s); s += 4; }
	else if (type == 'f') { left -= snprintf(d, left, "f:%g", *(float*)s);   s += 4; }
	else if (type == 'd') { left -= snprintf(d, left, "d:%lg", *(double*)s); s += 8; }
	else if (type == 'Z' || type == 'H') { left -= snprintf(d, left, "%c:", type);
	                                       strncat(d, (char *) s, left);
					       while (*s++) {}
					       left = sizeof(str) - strlen(str);
	                                     }
	if (left <= 0) continue;
	strncat(d,"\t",left);
	left--;
   }
   str[strlen(str)-1] = '\0';
   RETVAL = str;
#line 1625 "lib/Bio/DB/HTS.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_aux_get); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_aux_get)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "b, tag");
    {
	Bio__DB__HTS__Alignment	b;
	char*	tag = (char *)SvPV_nolen(ST(1))
;
#line 840 "lib/Bio/DB/HTS.xs"
   int           type;
   uint8_t       *s;
#line 1645 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::aux_get",
			"b", "Bio::DB::HTS::Alignment")
;
#line 843 "lib/Bio/DB/HTS.xs"
   s    = bam_aux_get(b,tag);
   if (s==0)
      XSRETURN_EMPTY;
   type = *s++;
   switch (type) {
   case 'c':
     RETVAL = newSViv((int32_t)*(int8_t*)s);
     break;
   case 'C':
     RETVAL = newSViv((int32_t)*(uint8_t*)s);
     break;
   case 's':
     RETVAL = newSViv((int32_t)*(int16_t*)s);
     break;
   case 'S':
     RETVAL = newSViv((int32_t)*(uint16_t*)s);
     break;
   case 'i':
     RETVAL = newSViv(*(int32_t*)s);
     break;
   case 'I':
     RETVAL = newSViv((int32_t)*(uint32_t*)s);
     break;
   case 'f':
     RETVAL = newSVnv(*(float*)s);
     break;
   case 'Z':
   case 'H':
     RETVAL = newSVpv((char*)s,0);
     break;
   case 'A':
     RETVAL = newSVpv((char*)s,1);
     break;
   default:
     XSRETURN_EMPTY;
   }
#line 1694 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_aux_keys); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_aux_keys)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Bio__DB__HTS__Alignment	b;
#line 887 "lib/Bio/DB/HTS.xs"
   uint8_t *s;
   uint8_t type;
#line 1715 "lib/Bio/DB/HTS.c"

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::aux_keys",
			"b", "Bio::DB::HTS::Alignment")
;
#line 890 "lib/Bio/DB/HTS.xs"
   {
     s = bam_get_aux(b);  /* s is a khash macro */
     while (s < b->data + b->l_data) {
       XPUSHs(sv_2mortal(newSVpv((char *) s, 2)));
       s   += 2;
       type = *s++;
       if      (type == 'A') { ++s; }
       else if (type == 'C') { ++s; }
       else if (type == 'c') { ++s; }
       else if (type == 'S') { s += 2; }
       else if (type == 's') { s += 2; }
       else if (type == 'I') { s += 4; }
       else if (type == 'i') { s += 4; }
       else if (type == 'f') { s += 4; }
       else if (type == 'Z' || type == 'H') { while (*s) ++(s); ++(s); }
     }
   }
#line 1744 "lib/Bio/DB/HTS.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_data); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_data)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
#line 913 "lib/Bio/DB/HTS.xs"
    STRLEN  len;
#line 1761 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::data",
			"b", "Bio::DB::HTS::Alignment")
;
#line 915 "lib/Bio/DB/HTS.xs"
    if (items > 1) {
      b->data     = (uint8_t *) SvPV(ST(1),len);
      b->l_data = len;
    }
    RETVAL=newSVpv((char *) b->data, b->l_data);
#line 1779 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_data_len); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_data_len)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::data_len",
			"b", "Bio::DB::HTS::Alignment")
;
#line 928 "lib/Bio/DB/HTS.xs"
    if (items > 1)
      b->l_data = SvIV(ST(1));
    RETVAL=b->l_data;
#line 1811 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_m_data); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_m_data)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "b, ...");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::m_data",
			"b", "Bio::DB::HTS::Alignment")
;
#line 939 "lib/Bio/DB/HTS.xs"
    if (items > 1) {
      b->m_data = SvIV(ST(1));
    }
    RETVAL=b->m_data;
#line 1843 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_qname); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_qname)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::qname",
			"b", "Bio::DB::HTS::Alignment")
;
#line 951 "lib/Bio/DB/HTS.xs"
    RETVAL=newSVpv(bam_get_qname(b),0);
#line 1871 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_paired); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_paired)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::paired",
			"b", "Bio::DB::HTS::Alignment")
;
#line 960 "lib/Bio/DB/HTS.xs"
    RETVAL=(b->core.flag&BAM_FPAIRED) != 0;
#line 1901 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_proper_pair); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_proper_pair)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::proper_pair",
			"b", "Bio::DB::HTS::Alignment")
;
#line 969 "lib/Bio/DB/HTS.xs"
    RETVAL=(b->core.flag&BAM_FPROPER_PAIR) != 0;
#line 1930 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_unmapped); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_unmapped)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::unmapped",
			"b", "Bio::DB::HTS::Alignment")
;
#line 978 "lib/Bio/DB/HTS.xs"
    RETVAL=(b->core.flag&BAM_FUNMAP) != 0;
#line 1959 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_munmapped); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_munmapped)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::munmapped",
			"b", "Bio::DB::HTS::Alignment")
;
#line 987 "lib/Bio/DB/HTS.xs"
    RETVAL=(b->core.flag&BAM_FMUNMAP) != 0;
#line 1988 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_reversed); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_reversed)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::reversed",
			"b", "Bio::DB::HTS::Alignment")
;
#line 996 "lib/Bio/DB/HTS.xs"
  RETVAL=bam_is_rev(b);
#line 2017 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_mreversed); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_mreversed)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::mreversed",
			"b", "Bio::DB::HTS::Alignment")
;
#line 1005 "lib/Bio/DB/HTS.xs"
  RETVAL=bam_is_mrev(b);
#line 2046 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Alignment_cigar); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Alignment_cigar)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "b");
    {
	Bio__DB__HTS__Alignment	b;
#line 1014 "lib/Bio/DB/HTS.xs"
    int        i;
    uint32_t  *c;
    AV        *avref;
#line 2065 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    b = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Alignment::cigar",
			"b", "Bio::DB::HTS::Alignment")
;
#line 1018 "lib/Bio/DB/HTS.xs"
    avref = (AV*) sv_2mortal((SV*)newAV());
    c     = bam_get_cigar(b);
    for (i=0;i<b->core.n_cigar;i++)
      av_push(avref, newSViv(c[i]));
    RETVAL = (SV*) newRV((SV*)avref);
#line 2083 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Header_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Header_new)
{
    dVAR; dXSARGS;
    if (items < 0 || items > 1)
       croak_xs_usage(cv,  "packname=Bio::DB::HTS::Header");
    {
	Bio__DB__HTS__Header	RETVAL;
#line 1032 "lib/Bio/DB/HTS.xs"
    RETVAL = bam_hdr_init();
#line 2101 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Header", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Header_n_targets); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Header_n_targets)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "bamh");
    {
	Bio__DB__HTS__Header	bamh;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Header::n_targets",
			"bamh", "Bio::DB::HTS::Header")
;
#line 1041 "lib/Bio/DB/HTS.xs"
    RETVAL = bamh->n_targets;
#line 2135 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Header_target_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Header_target_name)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "bamh");
    {
	Bio__DB__HTS__Header	bamh;
#line 1050 "lib/Bio/DB/HTS.xs"
    int i;
    AV * avref;
#line 2153 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Header::target_name",
			"bamh", "Bio::DB::HTS::Header")
;
#line 1053 "lib/Bio/DB/HTS.xs"
    avref = (AV*) sv_2mortal((SV*)newAV());
    for (i=0;i<bamh->n_targets;i++)
      av_push(avref, newSVpv(bamh->target_name[i],0));
    RETVAL = (SV*) newRV((SV*)avref);
#line 2170 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Header_target_len); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Header_target_len)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "bamh");
    {
	Bio__DB__HTS__Header	bamh;
#line 1065 "lib/Bio/DB/HTS.xs"
    int i;
    AV * avref;
#line 2189 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Header::target_len",
			"bamh", "Bio::DB::HTS::Header")
;
#line 1068 "lib/Bio/DB/HTS.xs"
    avref = (AV*) sv_2mortal((SV*)newAV());
    for (i=0;i<bamh->n_targets;i++)
       av_push(avref, newSViv(bamh->target_len[i]));
    RETVAL = (SV*) newRV((SV*)avref);
#line 2206 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Header_text); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Header_text)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "bamh, ...");
    {
	Bio__DB__HTS__Header	bamh;
#line 1079 "lib/Bio/DB/HTS.xs"
    char   *newtext;
    STRLEN n;
#line 2225 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Header::text",
			"bamh", "Bio::DB::HTS::Header")
;
#line 1082 "lib/Bio/DB/HTS.xs"
    /* in case text is not null terminated, we copy it */
    RETVAL = newSVpv(bamh->text,bamh->l_text);
    if (items > 1) {
      newtext = (char*) SvPV(ST(1),n);
      strcpy(bamh->text,newtext);
      bamh->l_text = n;
    }
#line 2245 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Header_parse_region); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Header_parse_region)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "bamh, region");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	Bio__DB__HTS__Header	bamh;
	char*	region = (char *)SvPV_nolen(ST(1))
;
#line 1099 "lib/Bio/DB/HTS.xs"
       int seqid,start,end;
#line 2267 "lib/Bio/DB/HTS.c"

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Header::parse_region",
			"bamh", "Bio::DB::HTS::Header")
;
#line 1101 "lib/Bio/DB/HTS.xs"
    {
      bam_parse_region(bamh,
		       region,
		       &seqid,
		       &start,
		       &end);
      if (seqid < 0)
	XSRETURN_EMPTY;
      else {
	EXTEND(sp,3);
	PUSHs(sv_2mortal(newSViv(seqid)));
	PUSHs(sv_2mortal(newSViv(start)));
	PUSHs(sv_2mortal(newSViv(end)));
      }
    }
#line 2294 "lib/Bio/DB/HTS.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Bio__DB__HTS__Header_view1); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Header_view1)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "bamh, alignment");
    {
	Bio__DB__HTS__Header	bamh;
	Bio__DB__HTS__Alignment	alignment;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Header::view1",
			"bamh", "Bio::DB::HTS::Header")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::Alignment")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    alignment = INT2PTR(Bio__DB__HTS__Alignment,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Header::view1",
			"alignment", "Bio::DB::HTS::Alignment")
;
#line 1123 "lib/Bio/DB/HTS.xs"
       bam_view1(bamh,alignment);
#line 2332 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Header_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Header_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "bamh");
    {
	Bio__DB__HTS__Header	bamh;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bamh = INT2PTR(Bio__DB__HTS__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"Bio::DB::HTS::Header::DESTROY",
			"bamh")
;
#line 1131 "lib/Bio/DB/HTS.xs"
    bam_hdr_destroy(bamh);
#line 2358 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Index_fetch); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Index_fetch)
{
    dVAR; dXSARGS;
    if (items < 6 || items > 7)
       croak_xs_usage(cv,  "bai, hfp, ref, start, end, callback, callbackdata=&PL_sv_undef");
    {
	Bio__DB__HTS__Index	bai;
	Bio__DB__HTSfile	hfp;
	int	ref = (int)SvIV(ST(2))
;
	int	start = (int)SvIV(ST(3))
;
	int	end = (int)SvIV(ST(4))
;
	CV*	callback;
	SV*	callbackdata;
#line 1147 "lib/Bio/DB/HTS.xs"
  fetch_callback_data fcd;
#line 2383 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Index")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bai = INT2PTR(Bio__DB__HTS__Index,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Index::fetch",
			"bai", "Bio::DB::HTS::Index")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    hfp = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Index::fetch",
			"hfp", "Bio::DB::HTSfile")
;

	STMT_START {
                HV *st;
                GV *gvp;
		SV * const xsub_tmp_sv = ST(5);
		SvGETMAGIC(xsub_tmp_sv);
                callback = sv_2cv(xsub_tmp_sv, &st, &gvp, 0);
		if (!callback) {
		    Perl_croak_nocontext("%s: %s is not a CODE reference",
				"Bio::DB::HTS::Index::fetch",
				"callback");
		}
	} STMT_END
;

	if (items < 7)
	    callbackdata = &PL_sv_undef;
	else {
	    callbackdata = ST(6)
;
	}
#line 1149 "lib/Bio/DB/HTS.xs"
  {
    fcd.callback = (SV*) callback;
    fcd.data     = callbackdata;
    RETVAL = hts_fetch(hfp,bai,ref,start,end,&fcd,hts_fetch_fun);
  }
#line 2433 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Index_pileup); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Index_pileup)
{
    dVAR; dXSARGS;
    if (items < 6 || items > 7)
       croak_xs_usage(cv,  "bai, hfp, ref, start, end, callback, callbackdata=&PL_sv_undef");
    {
	Bio__DB__HTS__Index	bai;
	Bio__DB__HTSfile	hfp;
	int	ref = (int)SvIV(ST(2))
;
	int	start = (int)SvIV(ST(3))
;
	int	end = (int)SvIV(ST(4))
;
	CV*	callback;
	SV*	callbackdata;
#line 1168 "lib/Bio/DB/HTS.xs"
  fetch_callback_data fcd;
  hts_plbuf_t        *pileup;
#line 2460 "lib/Bio/DB/HTS.c"

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Index")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bai = INT2PTR(Bio__DB__HTS__Index,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Index::pileup",
			"bai", "Bio::DB::HTS::Index")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    hfp = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Index::pileup",
			"hfp", "Bio::DB::HTSfile")
;

	STMT_START {
                HV *st;
                GV *gvp;
		SV * const xsub_tmp_sv = ST(5);
		SvGETMAGIC(xsub_tmp_sv);
                callback = sv_2cv(xsub_tmp_sv, &st, &gvp, 0);
		if (!callback) {
		    Perl_croak_nocontext("%s: %s is not a CODE reference",
				"Bio::DB::HTS::Index::pileup",
				"callback");
		}
	} STMT_END
;

	if (items < 7)
	    callbackdata = &PL_sv_undef;
	else {
	    callbackdata = ST(6)
;
	}
#line 1171 "lib/Bio/DB/HTS.xs"
  fcd.callback = (SV*) callback;
  fcd.data     = callbackdata;
  pileup       = hts_plbuf_init(invoke_pileup_callback_fun,(void*)&fcd);
  bam_plp_set_maxcnt(pileup->iter,MaxPileupCnt);
  hts_fetch(hfp,bai,ref,start,end,(void*)pileup,add_pileup_line);
  hts_plbuf_push(NULL,pileup);
  hts_plbuf_destroy(pileup);
#line 2510 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Index_coverage); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Index_coverage)
{
    dVAR; dXSARGS;
    if (items < 5 || items > 8)
       croak_xs_usage(cv,  "bai, hfp, ref, start, end, bins=0, maxcnt=8000, filter=NULL");
    {
	Bio__DB__HTS__Index	bai;
	Bio__DB__HTSfile	hfp;
	int	ref = (int)SvIV(ST(2))
;
	int	start = (int)SvIV(ST(3))
;
	int	end = (int)SvIV(ST(4))
;
	int	bins;
	int	maxcnt;
	SV*	filter;
#line 1190 "lib/Bio/DB/HTS.xs"
    coverage_graph  cg;
    hts_plbuf_t    *pileup;
    AV*             array;
    int             i, ret;
    bam_hdr_t      *bh;
    hts_itr_t      *iter;
    const htsFormat *format ;
#line 2542 "lib/Bio/DB/HTS.c"
	AV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Index")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    bai = INT2PTR(Bio__DB__HTS__Index,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Index::coverage",
			"bai", "Bio::DB::HTS::Index")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    hfp = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Index::coverage",
			"hfp", "Bio::DB::HTSfile")
;

	if (items < 6)
	    bins = 0;
	else {
	    bins = (int)SvIV(ST(5))
;
	}

	if (items < 7)
	    maxcnt = 8000;
	else {
	    maxcnt = (int)SvIV(ST(6))
;
	}

	if (items < 8)
	    filter = NULL;
	else {
	    filter = ST(7)
;
	}
#line 1198 "lib/Bio/DB/HTS.xs"
  {
      /* TODO:can we do away with this check by a move to CSI as the standard for BAM indices */
      if (end >= BAM_MAX_REGION)
      {
        format = hts_get_format( hfp ) ;
        if( format->format == bam ) //enum value from htsExactFormat from hts.h
        {
          bgzf_seek(hfp->fp.bgzf,0,0);
          bh = sam_hdr_read(hfp);
          end = bh->target_len[ref];
          bam_hdr_destroy(bh);
        }
      }
      if ((bins==0) || (bins > (end-start)))
         bins = end-start;

      /* coverage graph used to communicate to our callback
	  the region we are sampling */
      cg.start = start;
      cg.end   = end;
      cg.reads = 0;
      cg.width = ((double)(end-start))/bins;
      Newxz(cg.bin,bins+1,int);

      /* accumulate coverage into the coverage graph */
      pileup   = hts_plbuf_init(coverage_from_pileup_fun,(void*)&cg);
      if (items >= 7)
            bam_plp_set_maxcnt(pileup->iter,maxcnt);
      else
            bam_plp_set_maxcnt(pileup->iter,MaxPileupCnt);

      iter = sam_itr_queryi(bai, ref, start, end);

      if (items >= 8 && SvROK(filter) && SvTYPE(SvRV(filter)) == SVt_PVCV)
      {
        bam1_t *b = bam_init1();
        SV *b_sv = sv_setref_pv(newSV(sizeof b), "Bio::DB::HTS::Alignment", b);

        while ((ret = sam_itr_next(hfp, iter, b)) >= 0)
          if (invoke_sv_to_int_fun(filter, b_sv) != 0)
            hts_plbuf_push(b, pileup);

        SvREFCNT_dec(b_sv); /* b_sv's destructor will call bam_destroy1(b) */
      }
      else
      {
        bam1_t *b = bam_init1();
        while ((ret = sam_itr_next(hfp, iter, b)) >= 0)
          hts_plbuf_push(b, pileup);
        bam_destroy1(b);
      }

      hts_itr_destroy(iter);

      hts_plbuf_push(NULL,pileup);
      hts_plbuf_destroy(pileup);

      /* now normalize to coverage/bp and convert into an array */
      array = newAV();
      av_extend(array,bins);
      for  (i=0;i<bins;i++)
           av_store(array,i,newSVnv(((float)cg.bin[i])/cg.width));
      Safefree(cg.bin);
      RETVAL = array;
      sv_2mortal((SV*)RETVAL);  /* this fixes a documented bug in perl typemap */
  }
#line 2652 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = newRV((SV*)RETVAL);
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Index_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Index_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "hts_idx");
    {
	Bio__DB__HTS__Index	hts_idx;
#line 1272 "lib/Bio/DB/HTS.xs"
    HV *assocfile = get_hv("Bio::DB::HTS::_associated_file", GV_ADD);
#line 2674 "lib/Bio/DB/HTS.c"

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    hts_idx = INT2PTR(Bio__DB__HTS__Index,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"Bio::DB::HTS::Index::DESTROY",
			"hts_idx")
;
#line 1274 "lib/Bio/DB/HTS.xs"
    hts_idx_destroy(hts_idx) ;
    // Now release our reference to the associated Bio::DB::HTSfile
    hv_delete(assocfile, (char *) &hts_idx, sizeof hts_idx, 0);
#line 2689 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_qpos); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_qpos)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::qpos",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1286 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->qpos;
#line 2717 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_pos); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_pos)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::pos",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1294 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->qpos+1;
#line 2746 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_indel); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_indel)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::indel",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1302 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->indel;
#line 2775 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_level); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_level)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::level",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1310 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->level;
#line 2804 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_is_del); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_is_del)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::is_del",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1318 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->is_del;
#line 2833 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_is_refskip); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_is_refskip)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::is_refskip",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1326 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->is_refskip;
#line 2862 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_is_head); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_is_head)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::is_head",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1334 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->is_head;
#line 2891 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_is_tail); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_is_tail)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::is_tail",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1342 "lib/Bio/DB/HTS.xs"
    RETVAL = pl->is_tail;
#line 2920 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_b); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_b)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	Bio__DB__HTS__Alignment	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::b",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1350 "lib/Bio/DB/HTS.xs"
    RETVAL = bam_dup1(pl->b);
#line 2948 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Alignment", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Pileup_alignment); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Pileup_alignment)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "pl");
    {
	Bio__DB__HTS__Pileup	pl;
	Bio__DB__HTS__Alignment	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Pileup")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    pl = INT2PTR(Bio__DB__HTS__Pileup,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Pileup::alignment",
			"pl", "Bio::DB::HTS::Pileup")
;
#line 1358 "lib/Bio/DB/HTS.xs"
    RETVAL = bam_dup1(pl->b);
#line 2981 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Alignment", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_open); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_open)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "fname");
    {
	char *	fname = (char *)SvPV_nolen(ST(0))
;
	Bio__DB__HTS__Tabix	RETVAL;
#line 1370 "lib/Bio/DB/HTS.xs"
    RETVAL = tbx_index_load(fname);
#line 3005 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Tabix", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_close); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_close)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "t");
    {
	Bio__DB__HTS__Tabix	t;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Tabix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    t = INT2PTR(Bio__DB__HTS__Tabix,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::tbx_close",
			"t", "Bio::DB::HTS::Tabix")
;
#line 1379 "lib/Bio/DB/HTS.xs"
    tbx_destroy(t);
#line 3037 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_query); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_query)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "t, region");
    {
	Bio__DB__HTS__Tabix	t;
	char *	region = (char *)SvPV_nolen(ST(1))
;
	Bio__DB__HTS__Tabix__Iterator	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Tabix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    t = INT2PTR(Bio__DB__HTS__Tabix,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::tbx_query",
			"t", "Bio::DB::HTS::Tabix")
;
#line 1386 "lib/Bio/DB/HTS.xs"
    RETVAL = tbx_itr_querys(t, region);
#line 3066 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Tabix::Iterator", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_header); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_header)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "fp, tabix");
    {
	Bio__DB__HTSfile	fp;
	Bio__DB__HTS__Tabix	tabix;
#line 1397 "lib/Bio/DB/HTS.xs"
    int num_header_lines = 0;
    AV *av_ref;
    kstring_t str = {0,0,0};
#line 3091 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    fp = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::tbx_header",
			"fp", "Bio::DB::HTSfile")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::Tabix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    tabix = INT2PTR(Bio__DB__HTS__Tabix,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::tbx_header",
			"tabix", "Bio::DB::HTS::Tabix")
;
#line 1401 "lib/Bio/DB/HTS.xs"
    av_ref = newAV();
    while ( hts_getline(fp, KS_SEP_LINE, &str) >= 0 ) {
        if ( ! str.l ) break; //no lines left so we are done
        if ( str.s[0] != tabix->conf.meta_char ) break;

        //the line begins with a # so add it to the array
        ++num_header_lines;
        av_push(av_ref, newSVpv(str.s, str.l));
    }

    if ( ! num_header_lines )
        XSRETURN_EMPTY;

    RETVAL = newRV_noinc((SV*) av_ref);
    free(str.s);
#line 3129 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_seqnames); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Tabix_tbx_seqnames)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "t");
    {
	Bio__DB__HTS__Tabix	t;
#line 1423 "lib/Bio/DB/HTS.xs"
    const char **names;
    int i, num_seqs;
    AV *av_ref;
#line 3149 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Tabix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    t = INT2PTR(Bio__DB__HTS__Tabix,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::tbx_seqnames",
			"t", "Bio::DB::HTS::Tabix")
;
#line 1427 "lib/Bio/DB/HTS.xs"
    names = tbx_seqnames(t, &num_seqs); //call actual tabix method

    //blast all the values onto a perl array
    av_ref = newAV();
    for (i = 0; i < num_seqs; ++i) {
        SV *sv_ref = newSVpv(names[i], 0);
        av_push(av_ref, sv_ref);
    }

    free(names);

    //return a reference to our array
    RETVAL = newRV_noinc((SV*)av_ref);
#line 3175 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Tabix__Iterator_tbx_iter_next); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Tabix__Iterator_tbx_iter_next)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "iter, fp, t");
    {
	Bio__DB__HTS__Tabix__Iterator	iter;
	Bio__DB__HTSfile	fp;
	Bio__DB__HTS__Tabix	t;
#line 1451 "lib/Bio/DB/HTS.xs"
    kstring_t str = {0,0,0};
#line 3195 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Tabix::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    iter = INT2PTR(Bio__DB__HTS__Tabix__Iterator,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::Iterator::tbx_iter_next",
			"iter", "Bio::DB::HTS::Tabix::Iterator")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTSfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    fp = INT2PTR(Bio__DB__HTSfile,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::Iterator::tbx_iter_next",
			"fp", "Bio::DB::HTSfile")
;

	if (SvROK(ST(2)) && sv_derived_from(ST(2), "Bio::DB::HTS::Tabix")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    t = INT2PTR(Bio__DB__HTS__Tabix,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::Iterator::tbx_iter_next",
			"t", "Bio::DB::HTS::Tabix")
;
#line 1453 "lib/Bio/DB/HTS.xs"
    if (tbx_itr_next(fp, t, iter, &str) < 0) {
        free(str.s);
        XSRETURN_EMPTY;
    }

    RETVAL = newSVpv(str.s, str.l);
    free(str.s);

#line 3236 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Tabix__Iterator_tbx_iter_free); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Tabix__Iterator_tbx_iter_free)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "iter");
    {
	Bio__DB__HTS__Tabix__Iterator	iter;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Tabix::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    iter = INT2PTR(Bio__DB__HTS__Tabix__Iterator,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Tabix::Iterator::tbx_iter_free",
			"iter", "Bio::DB::HTS::Tabix::Iterator")
;
#line 1468 "lib/Bio/DB/HTS.xs"
	tbx_itr_destroy(iter);
#line 3264 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__VCFfile_open); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCFfile_open)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "packname, filename, mode=\"r\"");
    {
	char*	packname = (char *)SvPV_nolen(ST(0))
;
	char*	filename = (char *)SvPV_nolen(ST(1))
;
	char*	mode;
	Bio__DB__HTS__VCFfile	RETVAL;

	if (items < 3)
	    mode = "r";
	else {
	    mode = (char *)SvPV_nolen(ST(2))
;
	}
#line 1480 "lib/Bio/DB/HTS.xs"
      RETVAL = bcf_open(filename, mode);
#line 3292 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::VCFfile", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCFfile_tbx_index_load); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCFfile_tbx_index_load)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "packname, fname");
    {
	char*	packname = (char *)SvPV_nolen(ST(0))
;
	char *	fname = (char *)SvPV_nolen(ST(1))
;
	Bio__DB__HTS__Tabix	RETVAL;
#line 1490 "lib/Bio/DB/HTS.xs"
      htsFile *fp = hts_open(fname,"r");
      if ( !fp ) croak("Could not read %s\n", fname);
      enum htsExactFormat format = hts_get_format(fp)->format;
      if ( hts_close(fp) ) croak("hts_close returned non-zero status: %s\n", fname);

      if ( format != vcf ) XSRETURN_UNDEF;

      RETVAL = tbx_index_load(fname);
#line 3325 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Tabix", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCFfile_bcf_index_load); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCFfile_bcf_index_load)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "packname, filename");
    {
	char*	packname = (char *)SvPV_nolen(ST(0))
;
	char*	filename = (char *)SvPV_nolen(ST(1))
;
	Bio__DB__HTS__Index	RETVAL;
#line 1507 "lib/Bio/DB/HTS.xs"
         htsFile *fp = hts_open(filename,"r");
         if ( !fp ) croak("Could not read %s\n", filename);
         enum htsExactFormat format = hts_get_format(fp)->format;
	 if ( hts_close(fp) ) croak("hts_close returned non-zero status: %s\n", filename);

	 if ( format != bcf ) XSRETURN_UNDEF;

         RETVAL = bcf_index_load(filename);

#line 3359 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Index", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCFfile_bcf_index_close); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCFfile_bcf_index_close)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "packname, bcf_idx");
    {
	char*	packname = (char *)SvPV_nolen(ST(0))
;
	Bio__DB__HTS__Index	bcf_idx;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::Index")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    bcf_idx = INT2PTR(Bio__DB__HTS__Index,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCFfile::bcf_index_close",
			"bcf_idx", "Bio::DB::HTS::Index")
;
#line 1525 "lib/Bio/DB/HTS.xs"
         hts_idx_destroy(bcf_idx);
#line 3393 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__VCFfile_header_read); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCFfile_header_read)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "vfile");
    {
	Bio__DB__HTS__VCFfile	vfile;
#line 1532 "lib/Bio/DB/HTS.xs"
        bcf_hdr_t* h;
#line 3409 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__VCF__Header	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCFfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    vfile = INT2PTR(Bio__DB__HTS__VCFfile,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCFfile::header_read",
			"vfile", "Bio::DB::HTS::VCFfile")
;
#line 1534 "lib/Bio/DB/HTS.xs"
        h = bcf_hdr_read(vfile);
        RETVAL = h;
#line 3424 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::VCF::Header", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCFfile_read1); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCFfile_read1)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "vfile, header");
    {
	Bio__DB__HTS__VCFfile	vfile;
	Bio__DB__HTS__VCF__Header	header;
#line 1545 "lib/Bio/DB/HTS.xs"
        bcf1_t *rec;
#line 3447 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__VCF__Row	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCFfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    vfile = INT2PTR(Bio__DB__HTS__VCFfile,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCFfile::read1",
			"vfile", "Bio::DB::HTS::VCFfile")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCFfile::read1",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1547 "lib/Bio/DB/HTS.xs"
        rec = bcf_init();
        if ( bcf_read(vfile, header, rec) == 0 )
        {
            bcf_unpack(rec, BCF_UN_ALL) ;
            RETVAL = rec ;
        }
        else
        {
            XSRETURN_EMPTY;
        }
#line 3480 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::VCF::Row", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCFfile_num_variants); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCFfile_num_variants)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "packname, filename");
    {
	char*	packname = (char *)SvPV_nolen(ST(0))
;
	char*	filename = (char *)SvPV_nolen(ST(1))
;
#line 1567 "lib/Bio/DB/HTS.xs"
        int n_records = 0;
        vcfFile* vfile;
        bcf_hdr_t* h;
        bcf1_t *rec;
#line 3508 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;
#line 1572 "lib/Bio/DB/HTS.xs"
        vfile = bcf_open(filename, "r");
        h = bcf_hdr_read(vfile);
        rec = bcf_init();

        //loop through all the lines but don't do anything with them
        while(bcf_read(vfile, h, rec) == 0)
        {
            ++n_records;
        }
        bcf_destroy(rec);
        bcf_hdr_destroy(h);
        bcf_close(vfile) ;
        RETVAL = newSViv(n_records);
#line 3524 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCFfile_query); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCFfile_query)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "packname, region, ...");
    {
	char*	packname = (char *)SvPV_nolen(ST(0))
;
	char*	region = (char *)SvPV_nolen(ST(1))
;
	Bio__DB__HTS__VCF__Iterator	RETVAL;
#line 1593 "lib/Bio/DB/HTS.xs"
         if( items < 4 )
           croak("Missing arguments");

         if( !(SvOK(ST(2)) && sv_isobject(ST(2))))
	   croak("Invalid index argument");

         if( !(SvOK(ST(3)) && sv_isobject(ST(3))) )
	   croak("Invalid header argument");

#line 3554 "lib/Bio/DB/HTS.c"
#line 1603 "lib/Bio/DB/HTS.xs"
	 if ( sv_isa( ST(2), "Bio::DB::HTS::Tabix" ) ) {
	   RETVAL = tbx_itr_querys ( INT2PTR(tbx_t*, SvIV((SV *)SvRV(ST(2)))), region );
         } else if ( sv_isa( ST(2), "Bio::DB::HTS::Index" ) ) {
	   assert( sv_isa( ST(3), "Bio::DB::HTS::VCF::Header") );
	   RETVAL = bcf_itr_querys ( INT2PTR(hts_idx_t*, SvIV((SV *)SvRV(ST(2)))), INT2PTR(bcf_hdr_t*, SvIV((SV *)SvRV(ST(3)))), region );
         } else
           croak ( "Argument is not a valid index" );

         if ( RETVAL == NULL ) XSRETURN_UNDEF;

#line 3566 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::VCF::Iterator", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCFfile_vcf_close); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCFfile_vcf_close)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "vfile");
    {
	Bio__DB__HTS__VCFfile	vfile;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCFfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    vfile = INT2PTR(Bio__DB__HTS__VCFfile,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCFfile::vcf_close",
			"vfile", "Bio::DB::HTS::VCFfile")
;
#line 1621 "lib/Bio/DB/HTS.xs"
        bcf_close(vfile);
#line 3598 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Iterator_iter_next); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Iterator_iter_next)
{
    dVAR; dXSARGS;
    if (items < 3)
       croak_xs_usage(cv,  "iter, fp, hdr, ...");
    {
	Bio__DB__HTS__VCF__Iterator	iter;
	Bio__DB__HTS__VCFfile	fp;
	Bio__DB__HTS__VCF__Header	hdr;
#line 1631 "lib/Bio/DB/HTS.xs"
    kstring_t str = { 0, 0, 0 };
    bcf1_t *rec = bcf_init();
    int ret;

#line 3619 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__VCF__Row	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    iter = INT2PTR(Bio__DB__HTS__VCF__Iterator,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Iterator::iter_next",
			"iter", "Bio::DB::HTS::VCF::Iterator")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::VCFfile")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    fp = INT2PTR(Bio__DB__HTS__VCFfile,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Iterator::iter_next",
			"fp", "Bio::DB::HTS::VCFfile")
;

	if (SvROK(ST(2)) && sv_derived_from(ST(2), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(2)));
	    hdr = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Iterator::iter_next",
			"hdr", "Bio::DB::HTS::VCF::Header")
;
#line 1636 "lib/Bio/DB/HTS.xs"
    if ( items < 4 )
      croak("Missing arguments");

    if( !(SvOK(ST(3)) && sv_isobject(ST(3))) )
      croak("Invalid index argument");

#line 3658 "lib/Bio/DB/HTS.c"
#line 1643 "lib/Bio/DB/HTS.xs"
    if ( sv_isa( ST(3), "Bio::DB::HTS::Tabix" ) ) {
      if (tbx_itr_next(fp, INT2PTR(tbx_t*, SvIV((SV *)SvRV(ST(3)))), iter, &str) < 0 || vcf_parse1(&str, hdr, rec) < 0) {
        free(str.s);
	bcf_destroy(rec);
        XSRETURN_EMPTY;
      }

      free(str.s);

    } else if ( sv_isa( ST(3), "Bio::DB::HTS::Index" ) ) {
      if (bcf_itr_next(fp, iter, rec) < 0) {
        bcf_destroy(rec);
        XSRETURN_EMPTY;
      }
    } else
      croak ( "VCF/BCF file does not have a valid index" );

    bcf_unpack(rec, BCF_UN_ALL) ;
    RETVAL = rec;

#line 3680 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::VCF::Row", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Iterator_iter_free); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Iterator_iter_free)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "iter");
    {
	Bio__DB__HTS__VCF__Iterator	iter;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    iter = INT2PTR(Bio__DB__HTS__VCF__Iterator,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Iterator::iter_free",
			"iter", "Bio::DB::HTS::VCF::Iterator")
;
#line 1670 "lib/Bio/DB/HTS.xs"
	/* can call it also on a non-tabix index, 
	   see HTSlib synced_bcf_reader.c: bcf_sr_destroy1, _reader_fill_buffer */
	tbx_itr_destroy(iter);
#line 3714 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "h");
    {
	Bio__DB__HTS__VCF__Header	h;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    h = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"Bio::DB::HTS::VCF::Header::DESTROY",
			"h")
;
#line 1680 "lib/Bio/DB/HTS.xs"
        bcf_hdr_destroy(h);
#line 3740 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_version); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_version)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "header");
    {
	Bio__DB__HTS__VCF__Header	header;
#line 1686 "lib/Bio/DB/HTS.xs"
#line 3755 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Header::version",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1687 "lib/Bio/DB/HTS.xs"
     RETVAL = newSVpv(bcf_hdr_get_version(header),0) ;
#line 3769 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_num_samples); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_num_samples)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "header");
    {
	Bio__DB__HTS__VCF__Header	header;
#line 1696 "lib/Bio/DB/HTS.xs"
#line 3786 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Header::num_samples",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1697 "lib/Bio/DB/HTS.xs"
     RETVAL = bcf_hdr_nsamples(header) ;
#line 3801 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_get_sample_names); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_get_sample_names)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "header");
    {
	Bio__DB__HTS__VCF__Header	header;
#line 1706 "lib/Bio/DB/HTS.xs"
        int nsamples = 0 ;
        int i ;
        AV *av_ref;
#line 3820 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Header::get_sample_names",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1710 "lib/Bio/DB/HTS.xs"
        av_ref = newAV();
        nsamples = bcf_hdr_nsamples(header) ;
        for (i=0 ; i<nsamples ; i++)
        {
            SV *sv_ref = newSVpv(header->samples[i], 0);
            av_push(av_ref, sv_ref);
        }
        RETVAL = newRV_noinc((SV*)av_ref);
#line 3841 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_num_seqnames); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_num_seqnames)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "header");
    {
	Bio__DB__HTS__VCF__Header	header;
#line 1725 "lib/Bio/DB/HTS.xs"
        int nseq = 0 ;
#line 3859 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Header::num_seqnames",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1727 "lib/Bio/DB/HTS.xs"
     bcf_hdr_seqnames(header, &nseq);
     RETVAL = nseq;
#line 3875 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_get_seqnames); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_get_seqnames)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "header");
    {
	Bio__DB__HTS__VCF__Header	header;
#line 1737 "lib/Bio/DB/HTS.xs"
        int nseq = 0 ;
        const char **seqnames ;
        int i = 0 ;
        AV *av_ref = newAV() ;
#line 3895 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Header::get_seqnames",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1742 "lib/Bio/DB/HTS.xs"
        seqnames = bcf_hdr_seqnames(header, &nseq);
        for (i = 0; i < nseq; i++)
        {
            SV *sv_ref = newSVpv(seqnames[i], 0);
            av_push(av_ref, sv_ref);
        }
        free(seqnames) ;
        RETVAL = newRV_noinc((SV*)av_ref);
#line 3916 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_fmt_text); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Header_fmt_text)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "header");
    {
	Bio__DB__HTS__VCF__Header	header;
#line 1758 "lib/Bio/DB/HTS.xs"
  int len, is_bcf = 0; /* discard IDX fields */
#line 3934 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Header::fmt_text",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1760 "lib/Bio/DB/HTS.xs"
    /*
     * get header formatted text
     * use deprecated (since 1.4) bcf_hdr_fmt_text to support
     * older htslib versions
     * NOTE:
     *   using bcf_hdr_format is claimed to be better (optimised for huge headers),
     *   but for htslib >= 1.4 bcf_hdr_fmt_text calls bcf_hdr_format underneath
     *   and for htslib 1.3.1 bcf_hdr_fmt_text execute the same statements
     *   as bcf_hdr_format
     */
    RETVAL = newSVpv(bcf_hdr_fmt_text(header, is_bcf, &len), 0);
#line 3958 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_print); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_print)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "row, header");
    {
	Bio__DB__HTS__VCF__Row	row;
	Bio__DB__HTS__VCF__Header	header;
#line 1782 "lib/Bio/DB/HTS.xs"
     int i ;
#line 3977 "lib/Bio/DB/HTS.c"

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::print",
			"row", "Bio::DB::HTS::VCF::Row")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::print",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1784 "lib/Bio/DB/HTS.xs"
     printf("\nVCF data line:\n");
     printf("chromosome:%s\t", bcf_hdr_id2name(header,row->rid));
     printf("position:%d\t", (row->pos+1));
     printf("QUAL:%f\t", row->qual);
     printf("ID:%s\t", row->d.id );
     printf("REF:%s\n", row->d.als);
     printf("Num Alleles:%d\n", row->n_allele-1);
     for( i=1 ; i<row->n_allele ; i++ )
     {
       printf("ALT[%d]=%s\t", i, row->d.allele[i]);
     }
     printf("\nNum Filters:%d\n", row->d.n_flt);

#line 4012 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_chromosome); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_chromosome)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "row, header");
    {
	Bio__DB__HTS__VCF__Row	row;
	Bio__DB__HTS__VCF__Header	header;
#line 1807 "lib/Bio/DB/HTS.xs"
#line 4028 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::chromosome",
			"row", "Bio::DB::HTS::VCF::Row")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::chromosome",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1808 "lib/Bio/DB/HTS.xs"
     RETVAL = newSVpv(bcf_hdr_id2name(header,row->rid),0) ;
#line 4052 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_position); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_position)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "row");
    {
	Bio__DB__HTS__VCF__Row	row;
#line 1817 "lib/Bio/DB/HTS.xs"
#line 4069 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::position",
			"row", "Bio::DB::HTS::VCF::Row")
;
#line 1818 "lib/Bio/DB/HTS.xs"
     RETVAL = row->pos+1;
#line 4084 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_quality); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_quality)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "row");
    {
	Bio__DB__HTS__VCF__Row	row;
#line 1826 "lib/Bio/DB/HTS.xs"
#line 4100 "lib/Bio/DB/HTS.c"
	float	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::quality",
			"row", "Bio::DB::HTS::VCF::Row")
;
#line 1827 "lib/Bio/DB/HTS.xs"
     RETVAL = row->qual;
#line 4115 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_id)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "row");
    {
	Bio__DB__HTS__VCF__Row	row;
#line 1836 "lib/Bio/DB/HTS.xs"
#line 4131 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::id",
			"row", "Bio::DB::HTS::VCF::Row")
;
#line 1837 "lib/Bio/DB/HTS.xs"
     RETVAL = newSVpv(row->d.id, 0) ;
#line 4145 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_reference); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_reference)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "row");
    {
	Bio__DB__HTS__VCF__Row	row;
#line 1845 "lib/Bio/DB/HTS.xs"
#line 4162 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::reference",
			"row", "Bio::DB::HTS::VCF::Row")
;
#line 1846 "lib/Bio/DB/HTS.xs"
     RETVAL = newSVpv(row->d.als, 0) ;
#line 4176 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_num_alleles); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_num_alleles)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "row");
    {
	Bio__DB__HTS__VCF__Row	row;
#line 1855 "lib/Bio/DB/HTS.xs"
#line 4193 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::num_alleles",
			"row", "Bio::DB::HTS::VCF::Row")
;
#line 1856 "lib/Bio/DB/HTS.xs"
     RETVAL = row->n_allele-1 ;
#line 4208 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_alleles); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_alleles)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "row");
    {
	Bio__DB__HTS__VCF__Row	row;
#line 1865 "lib/Bio/DB/HTS.xs"
     int i;
     AV *av_ref;
#line 4226 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_alleles",
			"row", "Bio::DB::HTS::VCF::Row")
;
#line 1868 "lib/Bio/DB/HTS.xs"
     av_ref = newAV();
     for (i = 1; i < row->n_allele; ++i) {
        SV *sv_ref = newSVpv(row->d.allele[i], 0);
        av_push(av_ref, sv_ref);
     }
     RETVAL = newRV_noinc((SV*)av_ref);
#line 4245 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_num_filters); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_num_filters)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "row");
    {
	Bio__DB__HTS__VCF__Row	row;
#line 1881 "lib/Bio/DB/HTS.xs"
#line 4262 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::num_filters",
			"row", "Bio::DB::HTS::VCF::Row")
;
#line 1882 "lib/Bio/DB/HTS.xs"
     RETVAL = row->d.n_flt ;
#line 4277 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_has_filter); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_has_filter)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "row, header, filter");
    {
	Bio__DB__HTS__VCF__Row	row;
	Bio__DB__HTS__VCF__Header	header;
	char*	filter = (char *)SvPV_nolen(ST(2))
;
#line 1892 "lib/Bio/DB/HTS.xs"
#line 4296 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::has_filter",
			"row", "Bio::DB::HTS::VCF::Row")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::has_filter",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1893 "lib/Bio/DB/HTS.xs"
     RETVAL = bcf_has_filter(header,row,filter) ;
#line 4321 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_is_snp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_is_snp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "row");
    {
	Bio__DB__HTS__VCF__Row	row;
#line 1902 "lib/Bio/DB/HTS.xs"
#line 4337 "lib/Bio/DB/HTS.c"
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::is_snp",
			"row", "Bio::DB::HTS::VCF::Row")
;
#line 1903 "lib/Bio/DB/HTS.xs"
     RETVAL = bcf_is_snp(row) ;
#line 4352 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_variant_type); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_variant_type)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "row, allele_index");
    {
	Bio__DB__HTS__VCF__Row	row;
	int	allele_index = (int)SvIV(ST(1))
;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_variant_type",
			"row", "Bio::DB::HTS::VCF::Row")
;
#line 1913 "lib/Bio/DB/HTS.xs"
     RETVAL = bcf_get_variant_type(row, allele_index);
#line 4383 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_info_type); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_info_type)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "row, header, id");
    {
	Bio__DB__HTS__VCF__Row	row;
	Bio__DB__HTS__VCF__Header	header;
	char*	id = (char *)SvPV_nolen(ST(2))
;
#line 1924 "lib/Bio/DB/HTS.xs"
      bcf_info_t* info ;
#line 4403 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_info_type",
			"row", "Bio::DB::HTS::VCF::Row")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_info_type",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1926 "lib/Bio/DB/HTS.xs"
      info = bcf_get_info(header, row, id);
      if( info == NULL )
      {
        RETVAL = newSVpv("",0);
      }
      else
      {
        switch( info->type )
        {
          case BCF_BT_FLOAT:
               RETVAL = newSVpv("Float",0);
               break ;
          case BCF_BT_NULL:
               RETVAL = newSVpv("Flag",0);
               break ;
          case BCF_BT_CHAR:
               RETVAL = newSVpv("String",0);
               break ;
          default:
               RETVAL = newSVpv("Integer",0);
        }
      }
#line 4448 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_info); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_info)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "row, header, ...");
    {
	Bio__DB__HTS__VCF__Row	row;
	Bio__DB__HTS__VCF__Header	header;
#line 1957 "lib/Bio/DB/HTS.xs"
      bcf_info_t* info ;
      int i = 0, avi;
      int strlength = 0;
      int* buf_i;
      float* buf_f;
      char* buf_c;
      int result;

      vdict_t *d;
      khint_t k;
      AV* row_ids;
      HV* info_data;

#line 4479 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_info",
			"row", "Bio::DB::HTS::VCF::Row")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_info",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 1971 "lib/Bio/DB/HTS.xs"
      if ( items < 2 )
	croak ( "Missing arguments" );

      row_ids = newAV();
      if ( items > 2 ) {
        if ( SvOK(ST(2)) && SvTYPE(ST(2)) == SVt_PV ) {
	  av_push ( row_ids, newSVpv ( SvPVX(ST(2)) , 0) );
        } else
	  croak ( "ID argument must be a valid string" );
      } else {
	d = (vdict_t*)header->dict[BCF_DT_ID];
	if ( d == 0 ) croak ( "Couldn't get ID dict" );

	for ( k = kh_begin(d); k != kh_end(d); ++k )
	  if ( kh_exist(d, k) && bcf_get_info(header, row, kh_key(d, k)) != NULL )
	    av_push ( row_ids, newSVpv ( kh_key(d, k), 0) );
      }

#line 4520 "lib/Bio/DB/HTS.c"
#line 1991 "lib/Bio/DB/HTS.xs"
      info_data = newHV();

      for ( avi = 0; avi <= AvFILL(row_ids); ++avi ) {
	char* id = savepv( SvPV_nolen( *av_fetch ( row_ids, avi, 0 ) ) ) ;

        info = bcf_get_info(header, row, id);

        if( info == NULL ) { /* info null, nothing to return */
          hv_store( info_data, id, strlen(id), newSVpv("ID_NOT_FOUND", 0), 0 );
	} else {
          AV* av_ref = newAV();

          if( info->type == BCF_BT_NULL ) {
            buf_i = calloc(1, sizeof(int)) ;
            result = bcf_get_info_flag(header, row, id, &buf_i, &(info->len));

            if( result == 1 )
              av_push(av_ref, newSViv(1));
	    else
              av_push(av_ref, newSViv(0));

            free(buf_i);
          } else if( info->type == BCF_BT_FLOAT ) {
            buf_f = calloc(info->len, sizeof(float));
            result = bcf_get_info_float(header, row, id, &buf_f, &(info->len)) ;

            for( i=0 ; i<result ; i++ )
              av_push(av_ref, newSVnv(buf_f[i])) ;

            free(buf_f);
          } else if( info->type == BCF_BT_CHAR ) {
            strlength = info->len+1 ;
            buf_c = calloc(strlength, sizeof(char));
            result = bcf_get_info_string(header, row, id, &buf_c, &strlength) ;
            buf_c[info->len] = '\0' ;

            av_push(av_ref, newSVpv(buf_c,0));

            free(buf_c);
          } else if( info->type == BCF_BT_INT8 || info->type == BCF_BT_INT16 || info->type == BCF_BT_INT32 ) {
            buf_i = calloc(info->len, sizeof(int));
            result = bcf_get_info_int32(header, row, id, &buf_i, &(info->len)) ;

            for( i=0 ; i<result ; i++ )
              av_push(av_ref, newSViv(buf_i[i])) ;

            free(buf_i);
          }

	  hv_store ( info_data, id, strlen(id), newRV_noinc((SV*)av_ref), 0 );
	}
      }

      if ( AvFILL(row_ids) == 0 ) {
	STRLEN len;
	char* key = SvPV(*av_fetch(row_ids, 0, 0), len);

	SV** svp = hv_fetch( info_data, key, len, 0);
	if (svp != NULL) {
	  RETVAL = newSVsv(*svp);

	  SvREFCNT_dec((SV*)info_data);
	} else
	  croak ("Couldn't find key");

      } else
	RETVAL = newRV_noinc((SV*)info_data);

      SvREFCNT_dec((SV*)row_ids);

#line 4592 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_format_type); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_format_type)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "row, header, id");
    {
	Bio__DB__HTS__VCF__Row	row;
	Bio__DB__HTS__VCF__Header	header;
	char*	id = (char *)SvPV_nolen(ST(2))
;
#line 2071 "lib/Bio/DB/HTS.xs"
      bcf_fmt_t* fmt ;
#line 4613 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_format_type",
			"row", "Bio::DB::HTS::VCF::Row")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_format_type",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 2073 "lib/Bio/DB/HTS.xs"
      fmt = bcf_get_fmt(header, row, id);
      if( fmt == NULL )
      {
        RETVAL = newSVpv("",0);
      }
      else
      {
        switch( fmt->type )
        {
          case BCF_BT_FLOAT:
               RETVAL = newSVpv("Float",0);
               break ;
          case BCF_BT_CHAR:
               RETVAL = newSVpv("String",0);
               break ;
          default:
               RETVAL = newSVpv("Integer",0);
        }
      }
#line 4655 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_format); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_format)
{
    dVAR; dXSARGS;
    if (items < 2)
       croak_xs_usage(cv,  "row, header, ...");
    {
	Bio__DB__HTS__VCF__Row	row;
	Bio__DB__HTS__VCF__Header	header;
#line 2101 "lib/Bio/DB/HTS.xs"
      bcf_fmt_t* fmt;
      int i, avi;
      int* buf_i = NULL;
      float* buf_f = NULL;
      char* buf_c = NULL;
      int result;

      vdict_t *d;
      khint_t k;
      AV* row_ids;
      HV* fmt_data;

#line 4685 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_format",
			"row", "Bio::DB::HTS::VCF::Row")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_format",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 2114 "lib/Bio/DB/HTS.xs"
      if ( items < 2 )
	croak ( "Missing arguments" );

#line 4711 "lib/Bio/DB/HTS.c"
#line 2119 "lib/Bio/DB/HTS.xs"
      if ( items > 2 ) {
        if ( SvOK(ST(2)) && SvTYPE(ST(2)) == SVt_PV ) {
	  // av_push ( row_ids, newSVpv ( SvPVX(ST(2)) , 0) );

	  fmt = bcf_get_fmt(header, row, SvPVX(ST(2)));

	  if( fmt == NULL ) { /* fmt null, nothing to return */
	    RETVAL = newSVpv("ID_NOT_FOUND", 0);
	  } else {
	    AV* av_ref = (AV*) sv_2mortal((SV*) newAV() );

	    int ndst = 0;
	    if( fmt->type == BCF_BT_FLOAT ) {
	      result = bcf_get_format_float(header, row, SvPVX(ST(2)), &buf_f, &ndst) ;
	      if ( result < 0 )
		croak ("Couldn't read float format");

	      for( i=0 ; i<ndst ; i++ )
		av_push(av_ref, newSVnv(buf_f[i]));

	      free(buf_f);

	    } else if( fmt->type == BCF_BT_CHAR ) {
	      result = bcf_get_format_char(header, row, SvPVX(ST(2)), &buf_c, &ndst) ;
	      if ( result < 0 )
		croak ("Couldn't read string format");

	      av_push(av_ref, newSVpv(buf_c, ndst+1));
	      free(buf_c);

	    } else if( fmt->type == BCF_BT_INT8 || fmt->type == BCF_BT_INT16 || fmt->type == BCF_BT_INT32 ) {
	      result = bcf_get_format_int32(header, row, SvPVX(ST(2)), &buf_i, &ndst) ;
	      if ( result < 0 )
		croak ("Couldn't read int format");

	      for( i=0 ; i<ndst ; i++ )
		av_push(av_ref, newSViv(buf_i[i]));

	      free(buf_i);
	    }

	    RETVAL = newRV((SV*)av_ref);
	  }
        } else
	  croak ( "ID argument must be a valid string" );

      } else {
	fmt_data = (HV*) sv_2mortal( (SV*) newHV() );

	d = (vdict_t*)header->dict[BCF_DT_ID];
	if ( d == 0 ) croak ( "Couldn't get ID dict" );

	for ( k = kh_begin(d); k != kh_end(d); ++k )
	  if ( kh_exist(d, k) && (fmt = bcf_get_fmt(header, row, kh_key(d, k) ) ) != NULL ) {

	    AV* av_ref = (AV*) sv_2mortal((SV*) newAV() );

	    int ndst = 0;
	    if( fmt->type == BCF_BT_FLOAT ) {
	      result = bcf_get_format_float(header, row, kh_key(d, k), &buf_f, &ndst) ;
	      if ( result < 0 )
		croak ("Couldn't read float format");

	      for( i=0 ; i<ndst ; i++ )
		av_push(av_ref, newSVnv(buf_f[i]));

	      free(buf_f);

	    } else if( fmt->type == BCF_BT_CHAR ) {
	      result = bcf_get_format_char(header, row, kh_key(d, k), &buf_c, &ndst) ;
	      if ( result < 0 )
		croak ("Couldn't read string format");

	      av_push(av_ref, newSVpv(buf_c, ndst+1));
	      free(buf_c);

	    } else if( fmt->type == BCF_BT_INT8 || fmt->type == BCF_BT_INT16 || fmt->type == BCF_BT_INT32 ) {
	      result = bcf_get_format_int32(header, row, kh_key(d, k), &buf_i, &ndst) ;
	      if ( result < 0 )
		croak ("Couldn't read int format");

	      for( i=0 ; i<ndst ; i++ )
		av_push(av_ref, newSViv(buf_i[i]));

	      free(buf_i);
	    }

	    char* key = savepv((const char*) kh_key(d, k));
	    hv_store ( fmt_data, key, (I32)strlen(key), newRV((SV*) av_ref), 0 );
	  }

	RETVAL = newRV((SV*) fmt_data);
      }

#line 4807 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_genotypes); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_get_genotypes)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "row, header");
    {
	Bio__DB__HTS__VCF__Row	row;
	Bio__DB__HTS__VCF__Header	header;
#line 2222 "lib/Bio/DB/HTS.xs"
      int ngt ;
      int* gt_arr = NULL ;
      int ngt_arr = 0;
      AV* av_ref;
      int i=0 ;
#line 4830 "lib/Bio/DB/HTS.c"
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Row")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_genotypes",
			"row", "Bio::DB::HTS::VCF::Row")
;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::VCF::Header")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    header = INT2PTR(Bio__DB__HTS__VCF__Header,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Row::get_genotypes",
			"header", "Bio::DB::HTS::VCF::Header")
;
#line 2228 "lib/Bio/DB/HTS.xs"
      av_ref = newAV();
      /* Note the VCF header type treats this as a String but BCF treats as an int */
      ngt = bcf_get_genotypes(header, row, &gt_arr, &ngt_arr);
      for( i=0 ; i<ngt_arr ; i++ )
      {
        av_push(av_ref, newSViv(gt_arr[i])) ;
      }
      free(gt_arr);
      RETVAL = newRV_noinc((SV*)av_ref);
#line 4862 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Row_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "row");
    {
	Bio__DB__HTS__VCF__Row	row;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    row = INT2PTR(Bio__DB__HTS__VCF__Row,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"Bio::DB::HTS::VCF::Row::DESTROY",
			"row")
;
#line 2244 "lib/Bio/DB/HTS.xs"
      bcf_destroy(row);
#line 4890 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Sweep_sweep_open); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Sweep_sweep_open)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "filename");
    {
	char*	filename = (char *)SvPV_nolen(ST(0))
;
#line 2252 "lib/Bio/DB/HTS.xs"
        bcf_sweep_t* sweep;
#line 4907 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__VCF__Sweep	RETVAL;
#line 2254 "lib/Bio/DB/HTS.xs"
        sweep = bcf_sweep_init(filename);
        RETVAL = sweep;
#line 4912 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::VCF::Sweep", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Sweep_header_read); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Sweep_header_read)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sweep");
    {
	Bio__DB__HTS__VCF__Sweep	sweep;
#line 2263 "lib/Bio/DB/HTS.xs"
        bcf_hdr_t* h;
#line 4934 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__VCF__HeaderPtr	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Sweep")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sweep = INT2PTR(Bio__DB__HTS__VCF__Sweep,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Sweep::header_read",
			"sweep", "Bio::DB::HTS::VCF::Sweep")
;
#line 2265 "lib/Bio/DB/HTS.xs"
        h = bcf_sweep_hdr(sweep);
        RETVAL = h;
#line 4949 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::VCF::HeaderPtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Sweep_sweep_next); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Sweep_sweep_next)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sweep");
    {
	Bio__DB__HTS__VCF__Sweep	sweep;
#line 2274 "lib/Bio/DB/HTS.xs"
        bcf1_t* line;
#line 4971 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__VCF__RowPtr	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Sweep")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sweep = INT2PTR(Bio__DB__HTS__VCF__Sweep,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Sweep::sweep_next",
			"sweep", "Bio::DB::HTS::VCF::Sweep")
;
#line 2276 "lib/Bio/DB/HTS.xs"
        line = bcf_sweep_fwd(sweep);
        if( line )
        {
          RETVAL = line;
        }
        else
        {
          XSRETURN_EMPTY ;
        }
#line 4993 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::VCF::RowPtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Sweep_sweep_previous); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Sweep_sweep_previous)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sweep");
    {
	Bio__DB__HTS__VCF__Sweep	sweep;
#line 2292 "lib/Bio/DB/HTS.xs"
        bcf1_t* line;
#line 5015 "lib/Bio/DB/HTS.c"
	Bio__DB__HTS__VCF__RowPtr	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Sweep")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sweep = INT2PTR(Bio__DB__HTS__VCF__Sweep,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Sweep::sweep_previous",
			"sweep", "Bio::DB::HTS::VCF::Sweep")
;
#line 2294 "lib/Bio/DB/HTS.xs"
        line = bcf_sweep_bwd(sweep);
        if( line )
        {
          RETVAL = line;
        }
        else
        {
          XSRETURN_EMPTY ;
        }
#line 5037 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::VCF::RowPtr", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__VCF__Sweep_sweep_close); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__VCF__Sweep_sweep_close)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sweep");
    {
	Bio__DB__HTS__VCF__Sweep	sweep;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::VCF::Sweep")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    sweep = INT2PTR(Bio__DB__HTS__VCF__Sweep,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::VCF::Sweep::sweep_close",
			"sweep", "Bio::DB::HTS::VCF::Sweep")
;
#line 2310 "lib/Bio/DB/HTS.xs"
        bcf_sweep_destroy(sweep);
#line 5069 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq_new)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "package, filename, mode=\"r\"");
    {
	char *	package = (char *)SvPV_nolen(ST(0))
;
	char *	filename = (char *)SvPV_nolen(ST(1))
;
	char *	mode;
	Bio__DB__HTS__Kseq	RETVAL;

	if (items < 3)
	    mode = "r";
	else {
	    mode = (char *)SvPV_nolen(ST(2))
;
	}
#line 2323 "lib/Bio/DB/HTS.xs"
      RETVAL = gzopen(filename, mode);
#line 5097 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Kseq", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq_newfh); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq_newfh)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "pack, fh, mode=\"r\"");
    {
	char *	pack = (char *)SvPV_nolen(ST(0))
;
	PerlIO*	fh = IoIFP(sv_2io(ST(1)))
;
	char *	mode;
	Bio__DB__HTS__Kseq	RETVAL;

	if (items < 3)
	    mode = "r";
	else {
	    mode = (char *)SvPV_nolen(ST(2))
;
	}
#line 2334 "lib/Bio/DB/HTS.xs"
      RETVAL = gzdopen(PerlIO_fileno(fh), mode);
#line 5131 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Kseq", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq_iterator); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq_iterator)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "fp");
    {
	Bio__DB__HTS__Kseq	fp;
	Bio__DB__HTS__Kseq__Iterator	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    fp = INT2PTR(Bio__DB__HTS__Kseq,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::iterator",
			"fp", "Bio::DB::HTS::Kseq")
;
#line 2343 "lib/Bio/DB/HTS.xs"
      RETVAL = kseq_init(fp);
#line 5164 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Kseq::Iterator", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "fp");
    {
	Bio__DB__HTS__Kseq	fp;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    fp = INT2PTR(Bio__DB__HTS__Kseq,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"Bio::DB::HTS::Kseq::DESTROY",
			"fp")
;
#line 2352 "lib/Bio/DB/HTS.xs"
      gzclose(fp);
#line 5196 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_new)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "package, fh");
    {
	char *	package = (char *)SvPV_nolen(ST(0))
;
	Bio__DB__HTS__Kseq	fh;
	Bio__DB__HTS__Kseq__Kstream	RETVAL;

	if (SvROK(ST(1)) && sv_derived_from(ST(1), "Bio::DB::HTS::Kseq")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    fh = INT2PTR(Bio__DB__HTS__Kseq,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Kstream::new",
			"fh", "Bio::DB::HTS::Kseq")
;
#line 2362 "lib/Bio/DB/HTS.xs"
      RETVAL = ks_init(fh);
#line 5225 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Kseq::Kstream", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_begin); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_begin)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "kstr");
    {
	Bio__DB__HTS__Kseq__Kstream	kstr;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Kstream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    kstr = INT2PTR(Bio__DB__HTS__Kseq__Kstream,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Kstream::begin",
			"kstr", "Bio::DB::HTS::Kseq::Kstream")
;
#line 2371 "lib/Bio/DB/HTS.xs"
      RETVAL = kstr->begin;
#line 5259 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_end); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_end)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "kstr");
    {
	Bio__DB__HTS__Kseq__Kstream	kstr;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Kstream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    kstr = INT2PTR(Bio__DB__HTS__Kseq__Kstream,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Kstream::end",
			"kstr", "Bio::DB::HTS::Kseq::Kstream")
;
#line 2380 "lib/Bio/DB/HTS.xs"
      RETVAL = kstr->end;
#line 5288 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_is_eof); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_is_eof)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "kstr");
    {
	Bio__DB__HTS__Kseq__Kstream	kstr;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Kstream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    kstr = INT2PTR(Bio__DB__HTS__Kseq__Kstream,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Kstream::is_eof",
			"kstr", "Bio::DB::HTS::Kseq::Kstream")
;
#line 2389 "lib/Bio/DB/HTS.xs"
      RETVAL = kstr->is_eof;
#line 5317 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_buffer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_buffer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "kstr");
    {
	Bio__DB__HTS__Kseq__Kstream	kstr;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Kstream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    kstr = INT2PTR(Bio__DB__HTS__Kseq__Kstream,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Kstream::buffer",
			"kstr", "Bio::DB::HTS::Kseq::Kstream")
;
#line 2398 "lib/Bio/DB/HTS.xs"
      RETVAL = (char *)kstr->buf;
#line 5346 "lib/Bio/DB/HTS.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_fh); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_fh)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "kstr");
    {
	Bio__DB__HTS__Kseq__Kstream	kstr;
	Bio__DB__HTS__Kseq	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Kstream")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    kstr = INT2PTR(Bio__DB__HTS__Kseq__Kstream,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Kstream::fh",
			"kstr", "Bio::DB::HTS::Kseq::Kstream")
;
#line 2407 "lib/Bio/DB/HTS.xs"
      RETVAL = kstr->f;
#line 5374 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Kseq", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Kstream_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "kstr");
    {
	Bio__DB__HTS__Kseq__Kstream	kstr;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    kstr = INT2PTR(Bio__DB__HTS__Kseq__Kstream,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"Bio::DB::HTS::Kseq::Kstream::DESTROY",
			"kstr")
;
#line 2416 "lib/Bio/DB/HTS.xs"
      ks_destroy(kstr);
#line 5406 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_next_seq_hash); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_next_seq_hash)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::next_seq_hash",
			"it", "Bio::DB::HTS::Kseq::Iterator")
;
#line 2425 "lib/Bio/DB/HTS.xs"
      HV * results;
#line 5433 "lib/Bio/DB/HTS.c"
#line 2427 "lib/Bio/DB/HTS.xs"
      results = (HV *)sv_2mortal((SV *)newHV());
      if (kseq_read(it) >= 0) {
          hv_stores(results, "name", newSVpvn(it->name.s, it->name.l));
          hv_stores(results, "desc", newSVpvn(it->comment.s, it->comment.l));
          hv_stores(results, "seq", newSVpvn(it->seq.s, it->seq.l));
          hv_stores(results, "qual", newSVpvn(it->qual.s, it->qual.l));
          RETVAL = newRV((SV *)results);
      } else {
          XSRETURN_UNDEF;
      }
#line 5445 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_next_seq); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_next_seq)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	SV *	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::next_seq",
			"it", "Bio::DB::HTS::Kseq::Iterator")
;
#line 2445 "lib/Bio/DB/HTS.xs"
    HV * results;
    HV * class_stash;
    SV * ref;
#line 5476 "lib/Bio/DB/HTS.c"
#line 2449 "lib/Bio/DB/HTS.xs"
    results = (HV *)sv_2mortal((SV *)newHV());
    class_stash = gv_stashpv("Bio::DB::HTS::Kseq::Record", 0);
    if (kseq_read(it) >= 0) {
        hv_stores(results, "name", newSVpvn(it->name.s, it->name.l));
        hv_stores(results, "desc", newSVpvn(it->comment.s, it->comment.l));
        hv_stores(results, "seq", newSVpvn(it->seq.s, it->seq.l));
        hv_stores(results, "qual", newSVpvn(it->qual.s, it->qual.l));
        ref = newRV((SV *)results);
        sv_bless(ref, class_stash);
        RETVAL = ref;
    } else {
        XSRETURN_UNDEF;
    }
#line 5491 "lib/Bio/DB/HTS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_read); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_read)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::read",
			"it", "Bio::DB::HTS::Kseq::Iterator")
;
#line 2470 "lib/Bio/DB/HTS.xs"
#line 5520 "lib/Bio/DB/HTS.c"
#line 2471 "lib/Bio/DB/HTS.xs"
      RETVAL = kseq_read(it);
#line 5523 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_rewind); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_rewind)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::rewind",
			"it", "Bio::DB::HTS::Kseq::Iterator")
;
#line 2480 "lib/Bio/DB/HTS.xs"
      /* kseq_rewind() doesn't completely rewind the file,
        just resets markers */
      kseq_rewind(it);
      /* use zlib to do so */
      gzrewind(it->f->f);
#line 5554 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_kstream); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_kstream)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	Bio__DB__HTS__Kseq__Kstream	RETVAL;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::kstream",
			"it", "Bio::DB::HTS::Kseq::Iterator")
;
#line 2491 "lib/Bio/DB/HTS.xs"
      RETVAL = it->f;
#line 5581 "lib/Bio/DB/HTS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    sv_setref_pv(RETVALSV, "Bio::DB::HTS::Kseq::Kstream", (void*)RETVAL);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_name)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::name",
			"it", "Bio::DB::HTS::Kseq::Iterator")
;
#line 2500 "lib/Bio/DB/HTS.xs"
      RETVAL = it->name.s;
#line 5615 "lib/Bio/DB/HTS.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_comment); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_comment)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::comment",
			"it", "Bio::DB::HTS::Kseq::Iterator")
;
#line 2509 "lib/Bio/DB/HTS.xs"
      RETVAL = it->comment.s;
#line 5644 "lib/Bio/DB/HTS.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_seq); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_seq)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::seq",
			"it", "Bio::DB::HTS::Kseq::Iterator")
;
#line 2518 "lib/Bio/DB/HTS.xs"
      RETVAL = it->seq.s;
#line 5673 "lib/Bio/DB/HTS.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_qual); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_qual)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	char *	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::qual",
			"it", "Bio::DB::HTS::Kseq::Iterator")
;
#line 2527 "lib/Bio/DB/HTS.xs"
      RETVAL = it->qual.s;
#line 5702 "lib/Bio/DB/HTS.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_last_char); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_last_char)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;
	int	RETVAL;
	dXSTARG;

	if (SvROK(ST(0)) && sv_derived_from(ST(0), "Bio::DB::HTS::Kseq::Iterator")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not of type %s",
			"Bio::DB::HTS::Kseq::Iterator::last_char",
			"it", "Bio::DB::HTS::Kseq::Iterator")
;
#line 2536 "lib/Bio/DB/HTS.xs"
      RETVAL = it->last_char;
#line 5731 "lib/Bio/DB/HTS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Bio__DB__HTS__Kseq__Iterator_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "it");
    {
	Bio__DB__HTS__Kseq__Iterator	it;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    it = INT2PTR(Bio__DB__HTS__Kseq__Iterator,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"Bio::DB::HTS::Kseq::Iterator::DESTROY",
			"it")
;
#line 2545 "lib/Bio/DB/HTS.xs"
      kseq_destroy(it);
#line 5758 "lib/Bio/DB/HTS.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Bio__DB__HTS); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Bio__DB__HTS)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        (void)newXSproto_portable("Bio::DB::HTS::htslib_version", XS_Bio__DB__HTS_htslib_version, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Fai::load", XS_Bio__DB__HTS__Fai_load, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTS::Fai::DESTROY", XS_Bio__DB__HTS__Fai_DESTROY, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Fai::fetch", XS_Bio__DB__HTS__Fai_fetch, file, "$$$");
        newXS_deffile("Bio::DB::HTSfile::max_pileup_cnt", XS_Bio__DB__HTSfile_max_pileup_cnt);
        (void)newXSproto_portable("Bio::DB::HTSfile::is_remote", XS_Bio__DB__HTSfile_is_remote, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTSfile::open", XS_Bio__DB__HTSfile_open, file, "$$$");
        (void)newXSproto_portable("Bio::DB::HTSfile::DESTROY", XS_Bio__DB__HTSfile_DESTROY, file, "$");
        newXS_deffile("Bio::DB::HTSfile::index_build", XS_Bio__DB__HTSfile_index_build);
        (void)newXSproto_portable("Bio::DB::HTSfile::index_load", XS_Bio__DB__HTSfile_index_load, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTSfile::header_read", XS_Bio__DB__HTSfile_header_read, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTSfile::header_write", XS_Bio__DB__HTSfile_header_write, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTSfile::read1", XS_Bio__DB__HTSfile_read1, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTSfile::write1", XS_Bio__DB__HTSfile_write1, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::new", XS_Bio__DB__HTS__Alignment_new, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::DESTROY", XS_Bio__DB__HTS__Alignment_DESTROY, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::tid", XS_Bio__DB__HTS__Alignment_tid, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::pos", XS_Bio__DB__HTS__Alignment_pos, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::calend", XS_Bio__DB__HTS__Alignment_calend, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::cigar2qlen", XS_Bio__DB__HTS__Alignment_cigar2qlen, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::qual", XS_Bio__DB__HTS__Alignment_qual, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::flag", XS_Bio__DB__HTS__Alignment_flag, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::n_cigar", XS_Bio__DB__HTS__Alignment_n_cigar, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::l_qseq", XS_Bio__DB__HTS__Alignment_l_qseq, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::qseq", XS_Bio__DB__HTS__Alignment_qseq, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::_qscore", XS_Bio__DB__HTS__Alignment__qscore, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::mtid", XS_Bio__DB__HTS__Alignment_mtid, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::mpos", XS_Bio__DB__HTS__Alignment_mpos, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::isize", XS_Bio__DB__HTS__Alignment_isize, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::l_aux", XS_Bio__DB__HTS__Alignment_l_aux, file, "$;$");
        newXS_deffile("Bio::DB::HTS::Alignment::aux", XS_Bio__DB__HTS__Alignment_aux);
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::aux_get", XS_Bio__DB__HTS__Alignment_aux_get, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::aux_keys", XS_Bio__DB__HTS__Alignment_aux_keys, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::data", XS_Bio__DB__HTS__Alignment_data, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::data_len", XS_Bio__DB__HTS__Alignment_data_len, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::m_data", XS_Bio__DB__HTS__Alignment_m_data, file, "$;$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::qname", XS_Bio__DB__HTS__Alignment_qname, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::paired", XS_Bio__DB__HTS__Alignment_paired, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::proper_pair", XS_Bio__DB__HTS__Alignment_proper_pair, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::unmapped", XS_Bio__DB__HTS__Alignment_unmapped, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::munmapped", XS_Bio__DB__HTS__Alignment_munmapped, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::reversed", XS_Bio__DB__HTS__Alignment_reversed, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::mreversed", XS_Bio__DB__HTS__Alignment_mreversed, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Alignment::cigar", XS_Bio__DB__HTS__Alignment_cigar, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Header::new", XS_Bio__DB__HTS__Header_new, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Header::n_targets", XS_Bio__DB__HTS__Header_n_targets, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Header::target_name", XS_Bio__DB__HTS__Header_target_name, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Header::target_len", XS_Bio__DB__HTS__Header_target_len, file, "$");
        newXS_deffile("Bio::DB::HTS::Header::text", XS_Bio__DB__HTS__Header_text);
        (void)newXSproto_portable("Bio::DB::HTS::Header::parse_region", XS_Bio__DB__HTS__Header_parse_region, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Header::view1", XS_Bio__DB__HTS__Header_view1, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTS::Header::DESTROY", XS_Bio__DB__HTS__Header_DESTROY, file, "$");
        newXS_deffile("Bio::DB::HTS::Index::fetch", XS_Bio__DB__HTS__Index_fetch);
        newXS_deffile("Bio::DB::HTS::Index::pileup", XS_Bio__DB__HTS__Index_pileup);
        newXS_deffile("Bio::DB::HTS::Index::coverage", XS_Bio__DB__HTS__Index_coverage);
        newXS_deffile("Bio::DB::HTS::Index::DESTROY", XS_Bio__DB__HTS__Index_DESTROY);
        newXS_deffile("Bio::DB::HTS::Pileup::qpos", XS_Bio__DB__HTS__Pileup_qpos);
        newXS_deffile("Bio::DB::HTS::Pileup::pos", XS_Bio__DB__HTS__Pileup_pos);
        newXS_deffile("Bio::DB::HTS::Pileup::indel", XS_Bio__DB__HTS__Pileup_indel);
        newXS_deffile("Bio::DB::HTS::Pileup::level", XS_Bio__DB__HTS__Pileup_level);
        newXS_deffile("Bio::DB::HTS::Pileup::is_del", XS_Bio__DB__HTS__Pileup_is_del);
        newXS_deffile("Bio::DB::HTS::Pileup::is_refskip", XS_Bio__DB__HTS__Pileup_is_refskip);
        newXS_deffile("Bio::DB::HTS::Pileup::is_head", XS_Bio__DB__HTS__Pileup_is_head);
        newXS_deffile("Bio::DB::HTS::Pileup::is_tail", XS_Bio__DB__HTS__Pileup_is_tail);
        newXS_deffile("Bio::DB::HTS::Pileup::b", XS_Bio__DB__HTS__Pileup_b);
        newXS_deffile("Bio::DB::HTS::Pileup::alignment", XS_Bio__DB__HTS__Pileup_alignment);
        newXS_deffile("Bio::DB::HTS::Tabix::tbx_open", XS_Bio__DB__HTS__Tabix_tbx_open);
        newXS_deffile("Bio::DB::HTS::Tabix::tbx_close", XS_Bio__DB__HTS__Tabix_tbx_close);
        newXS_deffile("Bio::DB::HTS::Tabix::tbx_query", XS_Bio__DB__HTS__Tabix_tbx_query);
        newXS_deffile("Bio::DB::HTS::Tabix::tbx_header", XS_Bio__DB__HTS__Tabix_tbx_header);
        newXS_deffile("Bio::DB::HTS::Tabix::tbx_seqnames", XS_Bio__DB__HTS__Tabix_tbx_seqnames);
        newXS_deffile("Bio::DB::HTS::Tabix::Iterator::tbx_iter_next", XS_Bio__DB__HTS__Tabix__Iterator_tbx_iter_next);
        newXS_deffile("Bio::DB::HTS::Tabix::Iterator::tbx_iter_free", XS_Bio__DB__HTS__Tabix__Iterator_tbx_iter_free);
        (void)newXSproto_portable("Bio::DB::HTS::VCFfile::open", XS_Bio__DB__HTS__VCFfile_open, file, "$$$");
        (void)newXSproto_portable("Bio::DB::HTS::VCFfile::tbx_index_load", XS_Bio__DB__HTS__VCFfile_tbx_index_load, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTS::VCFfile::bcf_index_load", XS_Bio__DB__HTS__VCFfile_bcf_index_load, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTS::VCFfile::bcf_index_close", XS_Bio__DB__HTS__VCFfile_bcf_index_close, file, "$$");
        newXS_deffile("Bio::DB::HTS::VCFfile::header_read", XS_Bio__DB__HTS__VCFfile_header_read);
        newXS_deffile("Bio::DB::HTS::VCFfile::read1", XS_Bio__DB__HTS__VCFfile_read1);
        (void)newXSproto_portable("Bio::DB::HTS::VCFfile::num_variants", XS_Bio__DB__HTS__VCFfile_num_variants, file, "$$$");
        newXS_deffile("Bio::DB::HTS::VCFfile::query", XS_Bio__DB__HTS__VCFfile_query);
        newXS_deffile("Bio::DB::HTS::VCFfile::vcf_close", XS_Bio__DB__HTS__VCFfile_vcf_close);
        newXS_deffile("Bio::DB::HTS::VCF::Iterator::iter_next", XS_Bio__DB__HTS__VCF__Iterator_iter_next);
        newXS_deffile("Bio::DB::HTS::VCF::Iterator::iter_free", XS_Bio__DB__HTS__VCF__Iterator_iter_free);
        newXS_deffile("Bio::DB::HTS::VCF::Header::DESTROY", XS_Bio__DB__HTS__VCF__Header_DESTROY);
        newXS_deffile("Bio::DB::HTS::VCF::Header::version", XS_Bio__DB__HTS__VCF__Header_version);
        newXS_deffile("Bio::DB::HTS::VCF::Header::num_samples", XS_Bio__DB__HTS__VCF__Header_num_samples);
        newXS_deffile("Bio::DB::HTS::VCF::Header::get_sample_names", XS_Bio__DB__HTS__VCF__Header_get_sample_names);
        newXS_deffile("Bio::DB::HTS::VCF::Header::num_seqnames", XS_Bio__DB__HTS__VCF__Header_num_seqnames);
        newXS_deffile("Bio::DB::HTS::VCF::Header::get_seqnames", XS_Bio__DB__HTS__VCF__Header_get_seqnames);
        newXS_deffile("Bio::DB::HTS::VCF::Header::fmt_text", XS_Bio__DB__HTS__VCF__Header_fmt_text);
        newXS_deffile("Bio::DB::HTS::VCF::Row::print", XS_Bio__DB__HTS__VCF__Row_print);
        newXS_deffile("Bio::DB::HTS::VCF::Row::chromosome", XS_Bio__DB__HTS__VCF__Row_chromosome);
        newXS_deffile("Bio::DB::HTS::VCF::Row::position", XS_Bio__DB__HTS__VCF__Row_position);
        newXS_deffile("Bio::DB::HTS::VCF::Row::quality", XS_Bio__DB__HTS__VCF__Row_quality);
        newXS_deffile("Bio::DB::HTS::VCF::Row::id", XS_Bio__DB__HTS__VCF__Row_id);
        newXS_deffile("Bio::DB::HTS::VCF::Row::reference", XS_Bio__DB__HTS__VCF__Row_reference);
        newXS_deffile("Bio::DB::HTS::VCF::Row::num_alleles", XS_Bio__DB__HTS__VCF__Row_num_alleles);
        newXS_deffile("Bio::DB::HTS::VCF::Row::get_alleles", XS_Bio__DB__HTS__VCF__Row_get_alleles);
        newXS_deffile("Bio::DB::HTS::VCF::Row::num_filters", XS_Bio__DB__HTS__VCF__Row_num_filters);
        newXS_deffile("Bio::DB::HTS::VCF::Row::has_filter", XS_Bio__DB__HTS__VCF__Row_has_filter);
        newXS_deffile("Bio::DB::HTS::VCF::Row::is_snp", XS_Bio__DB__HTS__VCF__Row_is_snp);
        newXS_deffile("Bio::DB::HTS::VCF::Row::get_variant_type", XS_Bio__DB__HTS__VCF__Row_get_variant_type);
        newXS_deffile("Bio::DB::HTS::VCF::Row::get_info_type", XS_Bio__DB__HTS__VCF__Row_get_info_type);
        newXS_deffile("Bio::DB::HTS::VCF::Row::get_info", XS_Bio__DB__HTS__VCF__Row_get_info);
        newXS_deffile("Bio::DB::HTS::VCF::Row::get_format_type", XS_Bio__DB__HTS__VCF__Row_get_format_type);
        newXS_deffile("Bio::DB::HTS::VCF::Row::get_format", XS_Bio__DB__HTS__VCF__Row_get_format);
        newXS_deffile("Bio::DB::HTS::VCF::Row::get_genotypes", XS_Bio__DB__HTS__VCF__Row_get_genotypes);
        newXS_deffile("Bio::DB::HTS::VCF::Row::DESTROY", XS_Bio__DB__HTS__VCF__Row_DESTROY);
        newXS_deffile("Bio::DB::HTS::VCF::Sweep::sweep_open", XS_Bio__DB__HTS__VCF__Sweep_sweep_open);
        newXS_deffile("Bio::DB::HTS::VCF::Sweep::header_read", XS_Bio__DB__HTS__VCF__Sweep_header_read);
        newXS_deffile("Bio::DB::HTS::VCF::Sweep::sweep_next", XS_Bio__DB__HTS__VCF__Sweep_sweep_next);
        newXS_deffile("Bio::DB::HTS::VCF::Sweep::sweep_previous", XS_Bio__DB__HTS__VCF__Sweep_sweep_previous);
        newXS_deffile("Bio::DB::HTS::VCF::Sweep::sweep_close", XS_Bio__DB__HTS__VCF__Sweep_sweep_close);
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::new", XS_Bio__DB__HTS__Kseq_new, file, "$$$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::newfh", XS_Bio__DB__HTS__Kseq_newfh, file, "$$$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::iterator", XS_Bio__DB__HTS__Kseq_iterator, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::DESTROY", XS_Bio__DB__HTS__Kseq_DESTROY, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Kstream::new", XS_Bio__DB__HTS__Kseq__Kstream_new, file, "$$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Kstream::begin", XS_Bio__DB__HTS__Kseq__Kstream_begin, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Kstream::end", XS_Bio__DB__HTS__Kseq__Kstream_end, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Kstream::is_eof", XS_Bio__DB__HTS__Kseq__Kstream_is_eof, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Kstream::buffer", XS_Bio__DB__HTS__Kseq__Kstream_buffer, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Kstream::fh", XS_Bio__DB__HTS__Kseq__Kstream_fh, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Kstream::DESTROY", XS_Bio__DB__HTS__Kseq__Kstream_DESTROY, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::next_seq_hash", XS_Bio__DB__HTS__Kseq__Iterator_next_seq_hash, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::next_seq", XS_Bio__DB__HTS__Kseq__Iterator_next_seq, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::read", XS_Bio__DB__HTS__Kseq__Iterator_read, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::rewind", XS_Bio__DB__HTS__Kseq__Iterator_rewind, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::kstream", XS_Bio__DB__HTS__Kseq__Iterator_kstream, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::name", XS_Bio__DB__HTS__Kseq__Iterator_name, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::comment", XS_Bio__DB__HTS__Kseq__Iterator_comment, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::seq", XS_Bio__DB__HTS__Kseq__Iterator_seq, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::qual", XS_Bio__DB__HTS__Kseq__Iterator_qual, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::last_char", XS_Bio__DB__HTS__Kseq__Iterator_last_char, file, "$");
        (void)newXSproto_portable("Bio::DB::HTS::Kseq::Iterator::DESTROY", XS_Bio__DB__HTS__Kseq__Iterator_DESTROY, file, "$");
#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

